{"nodes": {"model.jaffle_shop.stg_customers": {"name": "stg_customers", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "resource_type": "model", "path": "staging/stg_customers.sql", "original_file_path": "models/staging/stg_customers.sql", "package_name": "jaffle_shop", "raw_sql": "with source as (\n\n    {#-\n    Normally we would select from the table here, but we are using seeds to load\n    our data in this project\n    #}\n    select * from {{ ref('raw_customers') }}\n\n),\n\nrenamed as (\n\n    select\n        id as customer_id,\n        first_name,\n        last_name,\n        email\n\n    from source\n\n)\n\nselect * from renamed", "refs": [["raw_customers"]], "sources": [], "depends_on": {"nodes": ["seed.jaffle_shop.raw_customers"], "macros": []}, "unique_id": "model.jaffle_shop.stg_customers", "empty": false, "fqn": ["jaffle_shop", "staging", "stg_customers"], "tags": ["staging", "hourly"], "config": {"enabled": true, "materialized": "view", "tags": ["staging", "hourly"], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "stg_customers", "columns": {"customer_id": {"name": "customer_id", "description": ""}}, "description": "", "patch_path": "models/staging/schema.yml", "docrefs": []}, "model.jaffle_shop.stg_payments": {"name": "stg_payments", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "resource_type": "model", "path": "staging/stg_payments.sql", "original_file_path": "models/staging/stg_payments.sql", "package_name": "jaffle_shop", "raw_sql": "with source as (\n    \n    {#-\n    Normally we would select from the table here, but we are using seeds to load\n    our data in this project\n    #}\n    select * from {{ ref('raw_payments') }}\n\n),\n\nrenamed as (\n\n    select\n        id as payment_id,\n        order_id,\n        payment_method,\n\n        --`amount` is currently stored in cents, so we convert it to dollars\n        amount / 100 as amount\n\n    from source\n\n)\n\nselect * from renamed", "refs": [["raw_payments"]], "sources": [], "depends_on": {"nodes": ["seed.jaffle_shop.raw_payments"], "macros": []}, "unique_id": "model.jaffle_shop.stg_payments", "empty": false, "fqn": ["jaffle_shop", "staging", "stg_payments"], "tags": ["staging", "hourly"], "config": {"enabled": true, "materialized": "view", "tags": ["staging", "hourly"], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "stg_payments", "columns": {"payment_id": {"name": "payment_id", "description": ""}, "payment_method": {"name": "payment_method", "description": ""}}, "description": "", "patch_path": "models/staging/schema.yml", "docrefs": []}, "model.jaffle_shop.stg_orders": {"name": "stg_orders", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "resource_type": "model", "path": "staging/stg_orders.sql", "original_file_path": "models/staging/stg_orders.sql", "package_name": "jaffle_shop", "raw_sql": "with source as (\n\n    {#-\n    Normally we would select from the table here, but we are using seeds to load\n    our data in this project\n    #}\n    select * from {{ ref('raw_orders') }}\n\n),\n\nrenamed as (\n\n    select\n        id as order_id,\n        user_id as customer_id,\n        order_date,\n        status\n\n    from source\n\n)\n\nselect * from renamed", "refs": [["raw_orders"]], "sources": [], "depends_on": {"nodes": ["seed.jaffle_shop.raw_orders"], "macros": []}, "unique_id": "model.jaffle_shop.stg_orders", "empty": false, "fqn": ["jaffle_shop", "staging", "stg_orders"], "tags": ["staging", "hourly"], "config": {"enabled": true, "materialized": "view", "tags": ["staging", "hourly"], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "stg_orders", "columns": {"order_id": {"name": "order_id", "description": ""}, "status": {"name": "status", "description": ""}}, "description": "", "patch_path": "models/staging/schema.yml", "docrefs": []}, "model.jaffle_shop.dim_customers": {"name": "dim_customers", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "resource_type": "model", "path": "marts/core/dim_customers.sql", "original_file_path": "models/marts/core/dim_customers.sql", "package_name": "jaffle_shop", "raw_sql": "with customers as (\n\n    select * from {{ ref('stg_customers') }}\n\n),\n\ncustomer_orders as (\n\n    select * from {{ ref('customer_orders') }}\n\n),\n\ncustomer_payments as (\n\n    select * from {{ ref('customer_payments') }}\n\n),\n\nfinal as (\n\n    select\n        customers.customer_id,\n        customer_orders.first_order,\n        customer_orders.most_recent_order,\n        customer_orders.number_of_orders,\n        customer_payments.total_amount as customer_lifetime_value\n\n    from customers\n\n    left join customer_orders using (customer_id)\n\n    left join customer_payments using (customer_id)\n\n)\n\nselect * from final", "refs": [["stg_customers"], ["customer_orders"], ["customer_payments"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.stg_customers", "model.jaffle_shop.customer_orders", "model.jaffle_shop.customer_payments"], "macros": []}, "unique_id": "model.jaffle_shop.dim_customers", "empty": false, "fqn": ["jaffle_shop", "marts", "core", "dim_customers"], "tags": [], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "dim_customers", "columns": {"customer_id": {"name": "customer_id", "description": "This is a unique identifier for a customer"}, "first_name": {"name": "first_name", "description": "Customer's first name. PII."}, "last_name": {"name": "last_name", "description": "Customer's last name. PII."}, "email": {"name": "email", "description": "Customer's email address. PII."}, "first_order": {"name": "first_order", "description": "Date (UTC) of a customer's first order"}, "most_recent_order": {"name": "most_recent_order", "description": "Date (UTC) of a customer's most recent order"}, "number_of_orders": {"name": "number_of_orders", "description": "Count of the number of orders a customer has placed"}, "total_order_amount": {"name": "total_order_amount", "description": "Total value (AUD) of a customer's orders"}}, "description": "This table has basic information about a customer, as well as some derived facts based on a customer's orders", "patch_path": "models/marts/core/schema.yml", "docrefs": []}, "model.jaffle_shop.fct_orders": {"name": "fct_orders", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "resource_type": "model", "path": "marts/core/fct_orders.sql", "original_file_path": "models/marts/core/fct_orders.sql", "package_name": "jaffle_shop", "raw_sql": "{% set payment_methods = ['credit_card', 'coupon', 'bank_transfer', 'gift_card'] %}\n\nwith orders as (\n\n    select * from {{ ref('stg_orders') }}\n\n),\n\norder_payments as (\n\n    select * from {{ ref('order_payments') }}\n\n),\n\nfinal as (\n\n    select\n        orders.order_id,\n        orders.customer_id,\n        orders.order_date,\n        orders.status,\n\n        {% for payment_method in payment_methods -%}\n\n        order_payments.{{payment_method}}_amount,\n\n        {% endfor -%}\n\n        order_payments.total_amount as amount\n\n    from orders\n\n    left join order_payments using (order_id)\n\n)\n\nselect * from final", "refs": [["stg_orders"], ["order_payments"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.stg_orders", "model.jaffle_shop.order_payments"], "macros": []}, "unique_id": "model.jaffle_shop.fct_orders", "empty": false, "fqn": ["jaffle_shop", "marts", "core", "fct_orders"], "tags": [], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "fct_orders", "columns": {"order_id": {"name": "order_id", "description": "This is a unique identifier for an order"}, "customer_id": {"name": "customer_id", "description": "Foreign key to the customers table"}, "order_date": {"name": "order_date", "description": "Date (UTC) that the order was placed"}, "status": {"name": "status", "description": "Orders can be one of the following statuses:\n\n| status         | description                                                                                                            |\n|----------------|------------------------------------------------------------------------------------------------------------------------|\n| placed         | The order has been placed but has not yet left the warehouse                                                           |\n| shipped        | The order has ben shipped to the customer and is currently in transit                                                  |\n| completed      | The order has been received by the customer                                                                            |\n| return_pending | The customer has indicated that they would like to return the order, but it has not yet been received at the warehouse |\n| returned       | The order has been returned by the customer and received at the warehouse                                              |"}, "amount": {"name": "amount", "description": "Total amount (AUD) of the order"}, "credit_card_amount": {"name": "credit_card_amount", "description": "Amount of the order (AUD) paid for by credit card"}, "coupon_amount": {"name": "coupon_amount", "description": "Amount of the order (AUD) paid for by coupon"}, "bank_transfer_amount": {"name": "bank_transfer_amount", "description": "Amount of the order (AUD) paid for by bank transfer"}, "gift_card_amount": {"name": "gift_card_amount", "description": "Amount of the order (AUD) paid for by gift card"}}, "description": "This table has basic information about orders, as well as some derived facts based on payments", "patch_path": "models/marts/core/schema.yml", "docrefs": [{"documentation_package": "", "documentation_name": "orders_status", "column_name": "status"}]}, "model.jaffle_shop.order_payments": {"name": "order_payments", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "resource_type": "model", "path": "marts/core/intermediate/order_payments.sql", "original_file_path": "models/marts/core/intermediate/order_payments.sql", "package_name": "jaffle_shop", "raw_sql": "{% set payment_methods = ['credit_card', 'coupon', 'bank_transfer', 'gift_card'] %}\n\nwith payments as (\n\n    select * from {{ ref('stg_payments') }}\n\n),\n\nfinal as (\n\n    select\n        order_id,\n\n        {% for payment_method in payment_methods -%}\n        sum(case when payment_method = '{{payment_method}}' then amount else 0 end) as {{payment_method}}_amount,\n        {% endfor -%}\n\n        sum(amount) as total_amount\n\n    from payments\n\n    group by 1\n\n)\n\nselect * from final", "refs": [["stg_payments"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.stg_payments"], "macros": []}, "unique_id": "model.jaffle_shop.order_payments", "empty": false, "fqn": ["jaffle_shop", "marts", "core", "intermediate", "order_payments"], "tags": [], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "order_payments", "columns": {}, "description": ""}, "model.jaffle_shop.customer_payments": {"name": "customer_payments", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "resource_type": "model", "path": "marts/core/intermediate/customer_payments.sql", "original_file_path": "models/marts/core/intermediate/customer_payments.sql", "package_name": "jaffle_shop", "raw_sql": "with payments as (\n\n    select * from {{ ref('stg_payments') }}\n\n),\n\norders as (\n\n    select * from {{ ref('stg_orders') }}\n\n),\n\nfinal as (\n\n    select\n        orders.customer_id,\n        sum(amount) as total_amount\n\n    from payments\n\n    left join orders using (order_id)\n\n    group by 1\n\n)\n\nselect * from final", "refs": [["stg_payments"], ["stg_orders"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.stg_payments", "model.jaffle_shop.stg_orders"], "macros": []}, "unique_id": "model.jaffle_shop.customer_payments", "empty": false, "fqn": ["jaffle_shop", "marts", "core", "intermediate", "customer_payments"], "tags": [], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "customer_payments", "columns": {}, "description": ""}, "model.jaffle_shop.customer_orders": {"name": "customer_orders", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "resource_type": "model", "path": "marts/core/intermediate/customer_orders.sql", "original_file_path": "models/marts/core/intermediate/customer_orders.sql", "package_name": "jaffle_shop", "raw_sql": "with orders as (\n\n    select * from {{ ref('stg_orders') }}\n\n),\n\nfinal as (\n\n    select\n        customer_id,\n\n        min(order_date) as first_order,\n        max(order_date) as most_recent_order,\n        count(order_id) as number_of_orders\n    from orders\n\n    group by 1\n\n)\n\nselect * from final", "refs": [["stg_orders"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.stg_orders"], "macros": []}, "unique_id": "model.jaffle_shop.customer_orders", "empty": false, "fqn": ["jaffle_shop", "marts", "core", "intermediate", "customer_orders"], "tags": [], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "customer_orders", "columns": {}, "description": ""}, "seed.jaffle_shop.raw_customers": {"path": "raw_customers.csv", "name": "raw_customers", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "resource_type": "seed", "raw_sql": "-- csv --", "package_name": "jaffle_shop", "original_file_path": "data/raw_customers.csv", "refs": [], "sources": [], "depends_on": {"nodes": [], "macros": []}, "unique_id": "seed.jaffle_shop.raw_customers", "empty": false, "fqn": ["jaffle_shop", "raw_customers"], "tags": [], "config": {"enabled": true, "materialized": "seed", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "raw_customers", "columns": {}, "description": ""}, "seed.jaffle_shop.raw_orders": {"path": "raw_orders.csv", "name": "raw_orders", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "resource_type": "seed", "raw_sql": "-- csv --", "package_name": "jaffle_shop", "original_file_path": "data/raw_orders.csv", "refs": [], "sources": [], "depends_on": {"nodes": [], "macros": []}, "unique_id": "seed.jaffle_shop.raw_orders", "empty": false, "fqn": ["jaffle_shop", "raw_orders"], "tags": [], "config": {"enabled": true, "materialized": "seed", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "raw_orders", "columns": {}, "description": ""}, "seed.jaffle_shop.raw_payments": {"path": "raw_payments.csv", "name": "raw_payments", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "resource_type": "seed", "raw_sql": "-- csv --", "package_name": "jaffle_shop", "original_file_path": "data/raw_payments.csv", "refs": [], "sources": [], "depends_on": {"nodes": [], "macros": []}, "unique_id": "seed.jaffle_shop.raw_payments", "empty": false, "fqn": ["jaffle_shop", "raw_payments"], "tags": [], "config": {"enabled": true, "materialized": "seed", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "raw_payments", "columns": {}, "description": ""}, "test.jaffle_shop.unique_stg_customers_customer_id": {"name": "unique_stg_customers_customer_id", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/unique_stg_customers_customer_id.sql", "original_file_path": "models/staging/schema.yml", "raw_sql": "{{ test_unique(model=ref('stg_customers'), column_name='customer_id') }}", "refs": [["stg_customers"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.stg_customers"], "macros": []}, "unique_id": "test.jaffle_shop.unique_stg_customers_customer_id", "empty": false, "fqn": ["jaffle_shop", "schema_test", "unique_stg_customers_customer_id"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "unique_stg_customers_customer_id", "column_name": "customer_id", "columns": {}, "description": ""}, "test.jaffle_shop.not_null_stg_customers_customer_id": {"name": "not_null_stg_customers_customer_id", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/not_null_stg_customers_customer_id.sql", "original_file_path": "models/staging/schema.yml", "raw_sql": "{{ test_not_null(model=ref('stg_customers'), column_name='customer_id') }}", "refs": [["stg_customers"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.stg_customers"], "macros": []}, "unique_id": "test.jaffle_shop.not_null_stg_customers_customer_id", "empty": false, "fqn": ["jaffle_shop", "schema_test", "not_null_stg_customers_customer_id"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "not_null_stg_customers_customer_id", "column_name": "customer_id", "columns": {}, "description": ""}, "test.jaffle_shop.unique_stg_orders_order_id": {"name": "unique_stg_orders_order_id", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/unique_stg_orders_order_id.sql", "original_file_path": "models/staging/schema.yml", "raw_sql": "{{ test_unique(model=ref('stg_orders'), column_name='order_id') }}", "refs": [["stg_orders"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.stg_orders"], "macros": []}, "unique_id": "test.jaffle_shop.unique_stg_orders_order_id", "empty": false, "fqn": ["jaffle_shop", "schema_test", "unique_stg_orders_order_id"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "unique_stg_orders_order_id", "column_name": "order_id", "columns": {}, "description": ""}, "test.jaffle_shop.not_null_stg_orders_order_id": {"name": "not_null_stg_orders_order_id", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/not_null_stg_orders_order_id.sql", "original_file_path": "models/staging/schema.yml", "raw_sql": "{{ test_not_null(model=ref('stg_orders'), column_name='order_id') }}", "refs": [["stg_orders"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.stg_orders"], "macros": []}, "unique_id": "test.jaffle_shop.not_null_stg_orders_order_id", "empty": false, "fqn": ["jaffle_shop", "schema_test", "not_null_stg_orders_order_id"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "not_null_stg_orders_order_id", "column_name": "order_id", "columns": {}, "description": ""}, "test.jaffle_shop.accepted_values_stg_orders_status__placed__shipped__completed__return_pending__returned": {"name": "accepted_values_stg_orders_status__placed__shipped__completed__return_pending__returned", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/accepted_values_stg_orders_758238c28b8980ea7fe9d60a8d851ea8.sql", "original_file_path": "models/staging/schema.yml", "raw_sql": "{{ test_accepted_values(model=ref('stg_orders'), column_name='status', values=['placed', 'shipped', 'completed', 'return_pending', 'returned']) }}", "refs": [["stg_orders"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.stg_orders"], "macros": []}, "unique_id": "test.jaffle_shop.accepted_values_stg_orders_status__placed__shipped__completed__return_pending__returned", "empty": false, "fqn": ["jaffle_shop", "schema_test", "accepted_values_stg_orders_status__placed__shipped__completed__return_pending__returned"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "accepted_values_stg_orders_status__placed__shipped__completed__return_pending__returned", "column_name": "status", "columns": {}, "description": ""}, "test.jaffle_shop.unique_stg_payments_payment_id": {"name": "unique_stg_payments_payment_id", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/unique_stg_payments_payment_id.sql", "original_file_path": "models/staging/schema.yml", "raw_sql": "{{ test_unique(model=ref('stg_payments'), column_name='payment_id') }}", "refs": [["stg_payments"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.stg_payments"], "macros": []}, "unique_id": "test.jaffle_shop.unique_stg_payments_payment_id", "empty": false, "fqn": ["jaffle_shop", "schema_test", "unique_stg_payments_payment_id"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "unique_stg_payments_payment_id", "column_name": "payment_id", "columns": {}, "description": ""}, "test.jaffle_shop.not_null_stg_payments_payment_id": {"name": "not_null_stg_payments_payment_id", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/not_null_stg_payments_payment_id.sql", "original_file_path": "models/staging/schema.yml", "raw_sql": "{{ test_not_null(model=ref('stg_payments'), column_name='payment_id') }}", "refs": [["stg_payments"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.stg_payments"], "macros": []}, "unique_id": "test.jaffle_shop.not_null_stg_payments_payment_id", "empty": false, "fqn": ["jaffle_shop", "schema_test", "not_null_stg_payments_payment_id"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "not_null_stg_payments_payment_id", "column_name": "payment_id", "columns": {}, "description": ""}, "test.jaffle_shop.accepted_values_stg_payments_payment_method__credit_card__coupon__bank_transfer__gift_card": {"name": "accepted_values_stg_payments_payment_method__credit_card__coupon__bank_transfer__gift_card", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/accepted_values_stg_payments_944011baab727320a6b119d4d81589ae.sql", "original_file_path": "models/staging/schema.yml", "raw_sql": "{{ test_accepted_values(model=ref('stg_payments'), column_name='payment_method', values=['credit_card', 'coupon', 'bank_transfer', 'gift_card']) }}", "refs": [["stg_payments"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.stg_payments"], "macros": []}, "unique_id": "test.jaffle_shop.accepted_values_stg_payments_payment_method__credit_card__coupon__bank_transfer__gift_card", "empty": false, "fqn": ["jaffle_shop", "schema_test", "accepted_values_stg_payments_payment_method__credit_card__coupon__bank_transfer__gift_card"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "accepted_values_stg_payments_payment_method__credit_card__coupon__bank_transfer__gift_card", "column_name": "payment_method", "columns": {}, "description": ""}, "test.jaffle_shop.unique_dim_customers_customer_id": {"name": "unique_dim_customers_customer_id", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/unique_dim_customers_customer_id.sql", "original_file_path": "models/marts/core/schema.yml", "raw_sql": "{{ test_unique(model=ref('dim_customers'), column_name='customer_id') }}", "refs": [["dim_customers"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.dim_customers"], "macros": []}, "unique_id": "test.jaffle_shop.unique_dim_customers_customer_id", "empty": false, "fqn": ["jaffle_shop", "schema_test", "unique_dim_customers_customer_id"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "unique_dim_customers_customer_id", "column_name": "customer_id", "columns": {}, "description": ""}, "test.jaffle_shop.not_null_dim_customers_customer_id": {"name": "not_null_dim_customers_customer_id", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/not_null_dim_customers_customer_id.sql", "original_file_path": "models/marts/core/schema.yml", "raw_sql": "{{ test_not_null(model=ref('dim_customers'), column_name='customer_id') }}", "refs": [["dim_customers"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.dim_customers"], "macros": []}, "unique_id": "test.jaffle_shop.not_null_dim_customers_customer_id", "empty": false, "fqn": ["jaffle_shop", "schema_test", "not_null_dim_customers_customer_id"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "not_null_dim_customers_customer_id", "column_name": "customer_id", "columns": {}, "description": ""}, "test.jaffle_shop.unique_fct_orders_order_id": {"name": "unique_fct_orders_order_id", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/unique_fct_orders_order_id.sql", "original_file_path": "models/marts/core/schema.yml", "raw_sql": "{{ test_unique(model=ref('fct_orders'), column_name='order_id') }}", "refs": [["fct_orders"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.fct_orders"], "macros": []}, "unique_id": "test.jaffle_shop.unique_fct_orders_order_id", "empty": false, "fqn": ["jaffle_shop", "schema_test", "unique_fct_orders_order_id"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "unique_fct_orders_order_id", "column_name": "order_id", "columns": {}, "description": ""}, "test.jaffle_shop.not_null_fct_orders_order_id": {"name": "not_null_fct_orders_order_id", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/not_null_fct_orders_order_id.sql", "original_file_path": "models/marts/core/schema.yml", "raw_sql": "{{ test_not_null(model=ref('fct_orders'), column_name='order_id') }}", "refs": [["fct_orders"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.fct_orders"], "macros": []}, "unique_id": "test.jaffle_shop.not_null_fct_orders_order_id", "empty": false, "fqn": ["jaffle_shop", "schema_test", "not_null_fct_orders_order_id"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "not_null_fct_orders_order_id", "column_name": "order_id", "columns": {}, "description": ""}, "test.jaffle_shop.not_null_fct_orders_customer_id": {"name": "not_null_fct_orders_customer_id", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/not_null_fct_orders_customer_id.sql", "original_file_path": "models/marts/core/schema.yml", "raw_sql": "{{ test_not_null(model=ref('fct_orders'), column_name='customer_id') }}", "refs": [["fct_orders"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.fct_orders"], "macros": []}, "unique_id": "test.jaffle_shop.not_null_fct_orders_customer_id", "empty": false, "fqn": ["jaffle_shop", "schema_test", "not_null_fct_orders_customer_id"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "not_null_fct_orders_customer_id", "column_name": "customer_id", "columns": {}, "description": ""}, "test.jaffle_shop.relationships_fct_orders_customer_id__customer_id__ref_dim_customers_": {"name": "relationships_fct_orders_customer_id__customer_id__ref_dim_customers_", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/relationships_fct_orders_535c445ac9111d4713c286f097da3132.sql", "original_file_path": "models/marts/core/schema.yml", "raw_sql": "{{ test_relationships(model=ref('fct_orders'), column_name='customer_id', field='customer_id', to=ref('dim_customers')) }}", "refs": [["fct_orders"], ["dim_customers"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.fct_orders", "model.jaffle_shop.dim_customers"], "macros": []}, "unique_id": "test.jaffle_shop.relationships_fct_orders_customer_id__customer_id__ref_dim_customers_", "empty": false, "fqn": ["jaffle_shop", "schema_test", "relationships_fct_orders_customer_id__customer_id__ref_dim_customers_"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "relationships_fct_orders_customer_id__customer_id__ref_dim_customers_", "column_name": "customer_id", "columns": {}, "description": ""}, "test.jaffle_shop.accepted_values_fct_orders_status__placed__shipped__completed__return_pending__returned": {"name": "accepted_values_fct_orders_status__placed__shipped__completed__return_pending__returned", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/accepted_values_fct_orders_758238c28b8980ea7fe9d60a8d851ea8.sql", "original_file_path": "models/marts/core/schema.yml", "raw_sql": "{{ test_accepted_values(model=ref('fct_orders'), column_name='status', values=['placed', 'shipped', 'completed', 'return_pending', 'returned']) }}", "refs": [["fct_orders"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.fct_orders"], "macros": []}, "unique_id": "test.jaffle_shop.accepted_values_fct_orders_status__placed__shipped__completed__return_pending__returned", "empty": false, "fqn": ["jaffle_shop", "schema_test", "accepted_values_fct_orders_status__placed__shipped__completed__return_pending__returned"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "accepted_values_fct_orders_status__placed__shipped__completed__return_pending__returned", "column_name": "status", "columns": {}, "description": ""}, "test.jaffle_shop.not_null_fct_orders_amount": {"name": "not_null_fct_orders_amount", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/not_null_fct_orders_amount.sql", "original_file_path": "models/marts/core/schema.yml", "raw_sql": "{{ test_not_null(model=ref('fct_orders'), column_name='amount') }}", "refs": [["fct_orders"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.fct_orders"], "macros": []}, "unique_id": "test.jaffle_shop.not_null_fct_orders_amount", "empty": false, "fqn": ["jaffle_shop", "schema_test", "not_null_fct_orders_amount"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "not_null_fct_orders_amount", "column_name": "amount", "columns": {}, "description": ""}, "test.jaffle_shop.not_null_fct_orders_credit_card_amount": {"name": "not_null_fct_orders_credit_card_amount", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/not_null_fct_orders_credit_card_amount.sql", "original_file_path": "models/marts/core/schema.yml", "raw_sql": "{{ test_not_null(model=ref('fct_orders'), column_name='credit_card_amount') }}", "refs": [["fct_orders"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.fct_orders"], "macros": []}, "unique_id": "test.jaffle_shop.not_null_fct_orders_credit_card_amount", "empty": false, "fqn": ["jaffle_shop", "schema_test", "not_null_fct_orders_credit_card_amount"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "not_null_fct_orders_credit_card_amount", "column_name": "credit_card_amount", "columns": {}, "description": ""}, "test.jaffle_shop.not_null_fct_orders_coupon_amount": {"name": "not_null_fct_orders_coupon_amount", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/not_null_fct_orders_coupon_amount.sql", "original_file_path": "models/marts/core/schema.yml", "raw_sql": "{{ test_not_null(model=ref('fct_orders'), column_name='coupon_amount') }}", "refs": [["fct_orders"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.fct_orders"], "macros": []}, "unique_id": "test.jaffle_shop.not_null_fct_orders_coupon_amount", "empty": false, "fqn": ["jaffle_shop", "schema_test", "not_null_fct_orders_coupon_amount"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "not_null_fct_orders_coupon_amount", "column_name": "coupon_amount", "columns": {}, "description": ""}, "test.jaffle_shop.not_null_fct_orders_bank_transfer_amount": {"name": "not_null_fct_orders_bank_transfer_amount", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/not_null_fct_orders_bank_transfer_amount.sql", "original_file_path": "models/marts/core/schema.yml", "raw_sql": "{{ test_not_null(model=ref('fct_orders'), column_name='bank_transfer_amount') }}", "refs": [["fct_orders"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.fct_orders"], "macros": []}, "unique_id": "test.jaffle_shop.not_null_fct_orders_bank_transfer_amount", "empty": false, "fqn": ["jaffle_shop", "schema_test", "not_null_fct_orders_bank_transfer_amount"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "not_null_fct_orders_bank_transfer_amount", "column_name": "bank_transfer_amount", "columns": {}, "description": ""}, "test.jaffle_shop.not_null_fct_orders_gift_card_amount": {"name": "not_null_fct_orders_gift_card_amount", "resource_type": "test", "package_name": "jaffle_shop", "root_path": "/Users/drew/fishtown/clients/jaffle_shop", "path": "schema_test/not_null_fct_orders_gift_card_amount.sql", "original_file_path": "models/marts/core/schema.yml", "raw_sql": "{{ test_not_null(model=ref('fct_orders'), column_name='gift_card_amount') }}", "refs": [["fct_orders"]], "sources": [], "depends_on": {"nodes": ["model.jaffle_shop.fct_orders"], "macros": []}, "unique_id": "test.jaffle_shop.not_null_fct_orders_gift_card_amount", "empty": false, "fqn": ["jaffle_shop", "schema_test", "not_null_fct_orders_gift_card_amount"], "tags": ["schema"], "config": {"enabled": true, "materialized": "table", "tags": [], "post-hook": [], "pre-hook": [], "vars": {}, "quoting": {}, "column_types": {}}, "schema": "demo_schema", "database": "analytics", "alias": "not_null_fct_orders_gift_card_amount", "column_name": "gift_card_amount", "columns": {}, "description": ""}}, "macros": {"macro.dbt.statement": {"path": "macros/core.sql", "original_file_path": "macros/core.sql", "package_name": "dbt", "raw_sql": "{% macro statement(name=None, fetch_result=False, auto_begin=True) -%}\n  {%- if execute: -%}\n    {%- set sql = render(caller()) -%}\n\n    {%- if name == 'main' -%}\n      {{ log('Writing runtime SQL for node \"{}\"'.format(model['unique_id'])) }}\n      {{ write(sql) }}\n    {%- endif -%}\n\n    {%- set status, res = adapter.execute(sql, auto_begin=auto_begin, fetch=fetch_result) -%}\n    {%- if name is not none -%}\n      {{ store_result(name, status=status, agate_table=res) }}\n    {%- endif -%}\n\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro noop_statement(name=None, status=None, res=None) -%}\n  {%- set sql = render(caller()) -%}\n\n  {%- if name == 'main' -%}\n    {{ log('Writing runtime SQL for node \"{}\"'.format(model['unique_id'])) }}\n    {{ write(sql) }}\n  {%- endif -%}\n\n  {%- if name is not none -%}\n    {{ store_result(name, status=status, agate_table=res) }}\n  {%- endif -%}\n\n{%- endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "statement", "unique_id": "macro.dbt.statement", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.noop_statement": {"path": "macros/core.sql", "original_file_path": "macros/core.sql", "package_name": "dbt", "raw_sql": "{% macro statement(name=None, fetch_result=False, auto_begin=True) -%}\n  {%- if execute: -%}\n    {%- set sql = render(caller()) -%}\n\n    {%- if name == 'main' -%}\n      {{ log('Writing runtime SQL for node \"{}\"'.format(model['unique_id'])) }}\n      {{ write(sql) }}\n    {%- endif -%}\n\n    {%- set status, res = adapter.execute(sql, auto_begin=auto_begin, fetch=fetch_result) -%}\n    {%- if name is not none -%}\n      {{ store_result(name, status=status, agate_table=res) }}\n    {%- endif -%}\n\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro noop_statement(name=None, status=None, res=None) -%}\n  {%- set sql = render(caller()) -%}\n\n  {%- if name == 'main' -%}\n    {{ log('Writing runtime SQL for node \"{}\"'.format(model['unique_id'])) }}\n    {{ write(sql) }}\n  {%- endif -%}\n\n  {%- if name is not none -%}\n    {{ store_result(name, status=status, agate_table=res) }}\n  {%- endif -%}\n\n{%- endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "noop_statement", "unique_id": "macro.dbt.noop_statement", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.run_hooks": {"path": "macros/materializations/helpers.sql", "original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "run_hooks", "unique_id": "macro.dbt.run_hooks", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.column_list": {"path": "macros/materializations/helpers.sql", "original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "column_list", "unique_id": "macro.dbt.column_list", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.column_list_for_create_table": {"path": "macros/materializations/helpers.sql", "original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "column_list_for_create_table", "unique_id": "macro.dbt.column_list_for_create_table", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.make_hook_config": {"path": "macros/materializations/helpers.sql", "original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "make_hook_config", "unique_id": "macro.dbt.make_hook_config", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.before_begin": {"path": "macros/materializations/helpers.sql", "original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "before_begin", "unique_id": "macro.dbt.before_begin", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.in_transaction": {"path": "macros/materializations/helpers.sql", "original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "in_transaction", "unique_id": "macro.dbt.in_transaction", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.after_commit": {"path": "macros/materializations/helpers.sql", "original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "after_commit", "unique_id": "macro.dbt.after_commit", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.drop_relation_if_exists": {"path": "macros/materializations/helpers.sql", "original_file_path": "macros/materializations/helpers.sql", "package_name": "dbt", "raw_sql": "{% macro run_hooks(hooks, inside_transaction=True) %}\n  {% for hook in hooks | selectattr('transaction', 'equalto', inside_transaction)  %}\n    {% if not inside_transaction and loop.first %}\n      {% call statement(auto_begin=inside_transaction) %}\n        commit;\n      {% endcall %}\n    {% endif %}\n    {% call statement(auto_begin=inside_transaction) %}\n      {{ hook.get('sql') }}\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n\n{% macro column_list(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro column_list_for_create_table(columns) %}\n  {%- for col in columns %}\n    {{ adapter.quote(col.name) }} {{ col.data_type }} {%- if not loop.last %},{% endif %}\n  {% endfor -%}\n{% endmacro %}\n\n\n{% macro make_hook_config(sql, inside_transaction) %}\n    {{ tojson({\"sql\": sql, \"transaction\": inside_transaction}) }}\n{% endmacro %}\n\n\n{% macro before_begin(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n\n{% macro in_transaction(sql) %}\n    {{ make_hook_config(sql, inside_transaction=True) }}\n{% endmacro %}\n\n\n{% macro after_commit(sql) %}\n    {{ make_hook_config(sql, inside_transaction=False) }}\n{% endmacro %}\n\n{% macro drop_relation_if_exists(relation) %}\n  {% if relation is not none %}\n    {{ adapter.drop_relation(relation) }}\n  {% endif %}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "drop_relation_if_exists", "unique_id": "macro.dbt.drop_relation_if_exists", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.create_csv_table": {"path": "macros/materializations/seed/seed.sql", "original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "create_csv_table", "unique_id": "macro.dbt.create_csv_table", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.reset_csv_table": {"path": "macros/materializations/seed/seed.sql", "original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "reset_csv_table", "unique_id": "macro.dbt.reset_csv_table", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.load_csv_rows": {"path": "macros/materializations/seed/seed.sql", "original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "load_csv_rows", "unique_id": "macro.dbt.load_csv_rows", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__create_csv_table": {"path": "macros/materializations/seed/seed.sql", "original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__create_csv_table", "unique_id": "macro.dbt.default__create_csv_table", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__reset_csv_table": {"path": "macros/materializations/seed/seed.sql", "original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__reset_csv_table", "unique_id": "macro.dbt.default__reset_csv_table", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.basic_load_csv_rows": {"path": "macros/materializations/seed/seed.sql", "original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "basic_load_csv_rows", "unique_id": "macro.dbt.basic_load_csv_rows", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__load_csv_rows": {"path": "macros/materializations/seed/seed.sql", "original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__load_csv_rows", "unique_id": "macro.dbt.default__load_csv_rows", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.materialization_seed_default": {"path": "macros/materializations/seed/seed.sql", "original_file_path": "macros/materializations/seed/seed.sql", "package_name": "dbt", "raw_sql": "{% macro create_csv_table(model) -%}\n  {{ adapter_macro('create_csv_table', model) }}\n{%- endmacro %}\n\n{% macro reset_csv_table(model, full_refresh, old_relation) -%}\n  {{ adapter_macro('reset_csv_table', model, full_refresh, old_relation) }}\n{%- endmacro %}\n\n{% macro load_csv_rows(model) -%}\n  {{ adapter_macro('load_csv_rows', model) }}\n{%- endmacro %}\n\n{% macro default__create_csv_table(model) %}\n  {%- set agate_table = model['agate_table'] -%}\n  {%- set column_override = model['config'].get('column_types', {}) -%}\n\n  {% set sql %}\n    create table {{ this.render(False) }} (\n        {%- for col_name in agate_table.column_names -%}\n            {%- set inferred_type = adapter.convert_type(agate_table, loop.index0) -%}\n            {%- set type = column_override.get(col_name, inferred_type) -%}\n            {{ col_name | string }} {{ type }} {%- if not loop.last -%}, {%- endif -%}\n        {%- endfor -%}\n    )\n  {% endset %}\n\n  {% call statement('_') -%}\n    {{ sql }}\n  {%- endcall %}\n\n  {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro default__reset_csv_table(model, full_refresh, old_relation) %}\n    {% set sql = \"\" %}\n    {% if full_refresh %}\n        {{ adapter.drop_relation(old_relation) }}\n        {% set sql = create_csv_table(model) %}\n    {% else %}\n        {{ adapter.truncate_relation(old_relation) }}\n        {% set sql = \"truncate table \" ~ old_relation %}\n    {% endif %}\n\n    {{ return(sql) }}\n{% endmacro %}\n\n\n{% macro basic_load_csv_rows(model, batch_size) %}\n    {% set agate_table = model['agate_table'] %}\n    {% set cols_sql = \", \".join(agate_table.column_names) %}\n    {% set bindings = [] %}\n\n    {% set statements = [] %}\n\n    {% for chunk in agate_table.rows | batch(batch_size) %}\n        {% set bindings = [] %}\n\n        {% for row in chunk %}\n            {% set _ = bindings.extend(row) %}\n        {% endfor %}\n\n        {% set sql %}\n            insert into {{ this.render(False) }} ({{ cols_sql }}) values\n            {% for row in chunk -%}\n                ({%- for column in agate_table.column_names -%}\n                    %s\n                    {%- if not loop.last%},{%- endif %}\n                {%- endfor -%})\n                {%- if not loop.last%},{%- endif %}\n            {%- endfor %}\n        {% endset %}\n\n        {% set _ = adapter.add_query(sql, bindings=bindings, abridge_sql_log=True) %}\n\n        {% if loop.index0 == 0 %}\n            {% set _ = statements.append(sql) %}\n        {% endif %}\n    {% endfor %}\n\n    {# Return SQL so we can render it out into the compiled files #}\n    {{ return(statements[0]) }}\n{% endmacro %}\n\n\n{% macro default__load_csv_rows(model) %}\n  {{ return(basic_load_csv_rows(model, 10000) )}}\n{% endmacro %}\n\n\n{% materialization seed, default %}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set csv_table = model[\"agate_table\"] -%}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% set create_table_sql = \"\" %}\n  {% if exists_as_view %}\n    {{ exceptions.raise_compiler_error(\"Cannot seed to '{}', it is a view\".format(old_relation)) }}\n  {% elif exists_as_table %}\n    {% set create_table_sql = reset_csv_table(model, full_refresh_mode, old_relation) %}\n  {% else %}\n    {% set create_table_sql = create_csv_table(model) %}\n  {% endif %}\n\n  {% set status = 'CREATE' if full_refresh_mode else 'INSERT' %}\n  {% set num_rows = (csv_table.rows | length) %}\n  {% set sql = load_csv_rows(model) %}\n\n  {% call noop_statement('main', status ~ ' ' ~ num_rows) %}\n    {{ create_table_sql }};\n    -- dbt seed --\n    {{ sql }}\n  {% endcall %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "materialization_seed_default", "unique_id": "macro.dbt.materialization_seed_default", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.dbt__incremental_delete": {"path": "macros/materializations/incremental/incremental.sql", "original_file_path": "macros/materializations/incremental/incremental.sql", "package_name": "dbt", "raw_sql": "{% macro dbt__incremental_delete(target_relation, tmp_relation) -%}\n\n  {%- set unique_key = config.require('unique_key') -%}\n\n  delete\n  from {{ target_relation }}\n  where ({{ unique_key }}) in (\n    select ({{ unique_key }})\n    from {{ tmp_relation.include(schema=False, database=False) }}\n  );\n\n{%- endmacro %}\n\n{% materialization incremental, default -%}\n  {%- set sql_where = config.get('sql_where') -%}\n  {%- set unique_key = config.get('unique_key') -%}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_incremental_tmp' -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n  {%- set target_relation = api.Relation.create(identifier=identifier, schema=schema, database=database,  type='table') -%}\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier,\n                                             schema=schema,\n                                             database=database, type='table') -%}\n\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_not_as_table = (old_relation is not none and not old_relation.is_table) -%}\n\n  {%- set should_truncate = (non_destructive_mode and full_refresh_mode and exists_as_table) -%}\n  {%- set should_drop = (not should_truncate and (full_refresh_mode or exists_not_as_table)) -%}\n  {%- set force_create = (flags.FULL_REFRESH and not flags.NON_DESTRUCTIVE) -%}\n\n  -- setup\n  {% if old_relation is none -%}\n    -- noop\n  {%- elif should_truncate -%}\n    {{ adapter.truncate_relation(old_relation) }}\n  {%- elif should_drop -%}\n    {{ adapter.drop_relation(old_relation) }}\n    {%- set old_relation = none -%}\n  {%- endif %}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% if force_create or old_relation is none -%}\n    {%- call statement('main') -%}\n      {{ create_table_as(False, target_relation, sql) }}\n    {%- endcall -%}\n  {%- else -%}\n     {%- call statement() -%}\n\n       {% set tmp_table_sql -%}\n         {# We are using a subselect instead of a CTE here to allow PostgreSQL to use indexes. -#}\n         select * from (\n           {{ sql }}\n         ) as dbt_incr_sbq\n\n         {% if sql_where %}\n         where ({{ sql_where }})\n           or ({{ sql_where }}) is null\n         {% endif %}\n       {%- endset %}\n\n       {{ dbt.create_table_as(True, tmp_relation, tmp_table_sql) }}\n\n     {%- endcall -%}\n\n     {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                           to_relation=target_relation) }}\n\n     {%- call statement('main') -%}\n       {% set dest_columns = adapter.get_columns_in_relation(target_relation) %}\n       {% set dest_cols_csv = dest_columns | map(attribute='quoted') | join(', ') %}\n\n       {% if unique_key is not none -%}\n\n         {{ dbt__incremental_delete(target_relation, tmp_relation) }}\n\n       {%- endif %}\n\n       insert into {{ target_relation }} ({{ dest_cols_csv }})\n       (\n         select {{ dest_cols_csv }}\n         from {{ tmp_relation.include(schema=False, database=False) }}\n       );\n     {% endcall %}\n  {%- endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n\n{%- endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "dbt__incremental_delete", "unique_id": "macro.dbt.dbt__incremental_delete", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.materialization_incremental_default": {"path": "macros/materializations/incremental/incremental.sql", "original_file_path": "macros/materializations/incremental/incremental.sql", "package_name": "dbt", "raw_sql": "{% macro dbt__incremental_delete(target_relation, tmp_relation) -%}\n\n  {%- set unique_key = config.require('unique_key') -%}\n\n  delete\n  from {{ target_relation }}\n  where ({{ unique_key }}) in (\n    select ({{ unique_key }})\n    from {{ tmp_relation.include(schema=False, database=False) }}\n  );\n\n{%- endmacro %}\n\n{% materialization incremental, default -%}\n  {%- set sql_where = config.get('sql_where') -%}\n  {%- set unique_key = config.get('unique_key') -%}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_incremental_tmp' -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n  {%- set target_relation = api.Relation.create(identifier=identifier, schema=schema, database=database,  type='table') -%}\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier,\n                                             schema=schema,\n                                             database=database, type='table') -%}\n\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n  {%- set full_refresh_mode = (flags.FULL_REFRESH == True) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_not_as_table = (old_relation is not none and not old_relation.is_table) -%}\n\n  {%- set should_truncate = (non_destructive_mode and full_refresh_mode and exists_as_table) -%}\n  {%- set should_drop = (not should_truncate and (full_refresh_mode or exists_not_as_table)) -%}\n  {%- set force_create = (flags.FULL_REFRESH and not flags.NON_DESTRUCTIVE) -%}\n\n  -- setup\n  {% if old_relation is none -%}\n    -- noop\n  {%- elif should_truncate -%}\n    {{ adapter.truncate_relation(old_relation) }}\n  {%- elif should_drop -%}\n    {{ adapter.drop_relation(old_relation) }}\n    {%- set old_relation = none -%}\n  {%- endif %}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% if force_create or old_relation is none -%}\n    {%- call statement('main') -%}\n      {{ create_table_as(False, target_relation, sql) }}\n    {%- endcall -%}\n  {%- else -%}\n     {%- call statement() -%}\n\n       {% set tmp_table_sql -%}\n         {# We are using a subselect instead of a CTE here to allow PostgreSQL to use indexes. -#}\n         select * from (\n           {{ sql }}\n         ) as dbt_incr_sbq\n\n         {% if sql_where %}\n         where ({{ sql_where }})\n           or ({{ sql_where }}) is null\n         {% endif %}\n       {%- endset %}\n\n       {{ dbt.create_table_as(True, tmp_relation, tmp_table_sql) }}\n\n     {%- endcall -%}\n\n     {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                           to_relation=target_relation) }}\n\n     {%- call statement('main') -%}\n       {% set dest_columns = adapter.get_columns_in_relation(target_relation) %}\n       {% set dest_cols_csv = dest_columns | map(attribute='quoted') | join(', ') %}\n\n       {% if unique_key is not none -%}\n\n         {{ dbt__incremental_delete(target_relation, tmp_relation) }}\n\n       {%- endif %}\n\n       insert into {{ target_relation }} ({{ dest_cols_csv }})\n       (\n         select {{ dest_cols_csv }}\n         from {{ tmp_relation.include(schema=False, database=False) }}\n       );\n     {% endcall %}\n  {%- endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n\n{%- endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "materialization_incremental_default", "unique_id": "macro.dbt.materialization_incremental_default", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.archive_scd_hash": {"path": "macros/materializations/archive/archive.sql", "original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "archive_scd_hash", "unique_id": "macro.dbt.archive_scd_hash", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__archive_scd_hash": {"path": "macros/materializations/archive/archive.sql", "original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__archive_scd_hash", "unique_id": "macro.dbt.default__archive_scd_hash", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.create_temporary_table": {"path": "macros/materializations/archive/archive.sql", "original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "create_temporary_table", "unique_id": "macro.dbt.create_temporary_table", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__create_temporary_table": {"path": "macros/materializations/archive/archive.sql", "original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__create_temporary_table", "unique_id": "macro.dbt.default__create_temporary_table", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.create_columns": {"path": "macros/materializations/archive/archive.sql", "original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "create_columns", "unique_id": "macro.dbt.create_columns", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__create_columns": {"path": "macros/materializations/archive/archive.sql", "original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__create_columns", "unique_id": "macro.dbt.default__create_columns", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.archive_update": {"path": "macros/materializations/archive/archive.sql", "original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "archive_update", "unique_id": "macro.dbt.archive_update", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__archive_update": {"path": "macros/materializations/archive/archive.sql", "original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__archive_update", "unique_id": "macro.dbt.default__archive_update", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.archive_select": {"path": "macros/materializations/archive/archive.sql", "original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "archive_select", "unique_id": "macro.dbt.archive_select", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.materialization_archive_default": {"path": "macros/materializations/archive/archive.sql", "original_file_path": "macros/materializations/archive/archive.sql", "package_name": "dbt", "raw_sql": "{#\n    Create SCD Hash SQL fields cross-db\n#}\n\n{% macro archive_scd_hash() %}\n  {{ adapter_macro('archive_scd_hash') }}\n{% endmacro %}\n\n{% macro default__archive_scd_hash() %}\n    md5(\"dbt_pk\" || '|' || \"dbt_updated_at\")\n{% endmacro %}\n\n{% macro create_temporary_table(sql, relation) %}\n  {{ return(adapter_macro('create_temporary_table', sql, relation)) }}\n{% endmacro %}\n\n{% macro default__create_temporary_table(sql, relation) %}\n    {% call statement() %}\n        {{ create_table_as(True, relation, sql) }}\n    {% endcall %}\n    {{ return(relation) }}\n{% endmacro %}\n\n{#\n    Add new columns to the table if applicable\n#}\n{% macro create_columns(relation, columns) %}\n  {{ adapter_macro('create_columns', relation, columns) }}\n{% endmacro %}\n\n{% macro default__create_columns(relation, columns) %}\n  {% for column in columns %}\n    {% call statement() %}\n      alter table {{ relation }} add column \"{{ column.name }}\" {{ column.data_type }};\n    {% endcall %}\n  {% endfor %}\n{% endmacro %}\n\n{#\n    Run the update part of an archive query. Different databases have\n    tricky differences in their `update` semantics. Table projection is\n    not allowed on Redshift/pg, but is effectively required on bq.\n#}\n\n{% macro archive_update(target_relation, tmp_relation) %}\n    {{ adapter_macro('archive_update', target_relation, tmp_relation) }}\n{% endmacro %}\n\n{% macro default__archive_update(target_relation, tmp_relation) %}\n    update {{ target_relation }}\n    set {{ adapter.quote('valid_to') }} = tmp.{{ adapter.quote('valid_to') }}\n    from {{ tmp_relation }} as tmp\n    where tmp.{{ adapter.quote('scd_id') }} = {{ target_relation }}.{{ adapter.quote('scd_id') }}\n      and {{ adapter.quote('change_type') }} = 'update';\n{% endmacro %}\n\n\n{#\n    Cross-db compatible archival implementation\n#}\n{% macro archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) %}\n\n    {% set timestamp_column = api.Column.create('_', 'timestamp') %}\n\n    with current_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }} {% if not loop.last %},{% endif %}\n            {% endfor %},\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ updated_at }} as {{ adapter.quote('valid_from') }},\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ source_relation }}\n\n    ),\n\n    archived_data as (\n\n        select\n            {% for col in source_columns %}\n                {{ adapter.quote(col.name) }},\n            {% endfor %}\n            {{ updated_at }} as {{ adapter.quote('dbt_updated_at') }},\n            {{ unique_key }} as {{ adapter.quote('dbt_pk') }},\n            {{ adapter.quote('valid_from') }},\n            {{ adapter.quote('valid_to') }} as {{ adapter.quote('tmp_valid_to') }}\n        from {{ target_relation }}\n\n    ),\n\n    insertions as (\n\n        select\n            current_data.*,\n            {{ timestamp_column.literal('null') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is null or (\n          archived_data.{{ adapter.quote('dbt_pk') }} is not null and\n          current_data.{{ adapter.quote('dbt_updated_at') }} > archived_data.{{ adapter.quote('dbt_updated_at') }} and\n          archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n        )\n    ),\n\n    updates as (\n\n        select\n            archived_data.*,\n            current_data.{{ adapter.quote('dbt_updated_at') }} as {{ adapter.quote('valid_to') }}\n        from current_data\n        left outer join archived_data\n          on archived_data.{{ adapter.quote('dbt_pk') }} = current_data.{{ adapter.quote('dbt_pk') }}\n        where archived_data.{{ adapter.quote('dbt_pk') }} is not null\n          and archived_data.{{ adapter.quote('dbt_updated_at') }} < current_data.{{ adapter.quote('dbt_updated_at') }}\n          and archived_data.{{ adapter.quote('tmp_valid_to') }} is null\n    ),\n\n    merged as (\n\n      select *, 'update' as {{ adapter.quote('change_type') }} from updates\n      union all\n      select *, 'insert' as {{ adapter.quote('change_type') }} from insertions\n\n    )\n\n    select *,\n        {{ archive_scd_hash() }} as {{ adapter.quote('scd_id') }}\n    from merged\n\n{% endmacro %}\n\n{% materialization archive, default %}\n  {%- set config = model['config'] -%}\n\n  {%- set target_database = config.get('target_database') -%}\n  {%- set target_schema = config.get('target_schema') -%}\n  {%- set target_table = config.get('target_table') -%}\n\n  {%- set source_database = config.get('source_database') -%}\n  {%- set source_schema = config.get('source_schema') -%}\n  {%- set source_table = config.get('source_table') -%}\n\n  {{ create_schema(target_database, target_schema) }}\n\n  {%- set source_relation = adapter.get_relation(\n      database=source_database,\n      schema=source_schema,\n      identifier=source_table) -%}\n\n  {%- set target_relation = adapter.get_relation(\n      database=target_database,\n      schema=target_schema,\n      identifier=target_table) -%}\n\n  {%- if source_relation is none -%}\n    {{ exceptions.missing_relation('.'.join([source_database, source_schema, source_table])) }}\n  {%- endif -%}\n\n  {%- if target_relation is none -%}\n    {%- set target_relation = api.Relation.create(\n        database=target_database,\n        schema=target_schema,\n        identifier=target_table) -%}\n  {%- elif not target_relation.is_table -%}\n    {{ exceptions.relation_wrong_type(target_relation, 'table') }}\n  {%- endif -%}\n\n  {%- set source_columns = adapter.get_columns_in_relation(source_relation) -%}\n  {%- set unique_key = config.get('unique_key') -%}\n  {%- set updated_at = config.get('updated_at') -%}\n  {%- set dest_columns = source_columns + [\n      api.Column.create('valid_from', 'timestamp'),\n      api.Column.create('valid_to', 'timestamp'),\n      api.Column.create('scd_id', 'string'),\n      api.Column.create('dbt_updated_at', 'timestamp'),\n  ] -%}\n\n  {% call statement() %}\n    {{ create_archive_table(target_relation, dest_columns) }}\n  {% endcall %}\n\n  {% set missing_columns = adapter.get_missing_columns(source_relation, target_relation) %}\n\n  {{ create_columns(target_relation, missing_columns) }}\n\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_archival_tmp' -%}\n\n  {% set tmp_table_sql -%}\n\n      with dbt_archive_sbq as (\n        {{ archive_select(source_relation, target_relation, source_columns, unique_key, updated_at) }}\n      )\n      select * from dbt_archive_sbq\n\n  {%- endset %}\n\n  {%- set tmp_relation = api.Relation.create(identifier=tmp_identifier, type='table') -%}\n  {%- set tmp_relation = create_temporary_table(tmp_table_sql, tmp_relation) -%}\n\n  {{ adapter.expand_target_column_types(temp_table=tmp_identifier,\n                                        to_relation=target_relation) }}\n\n  {% call statement('_') -%}\n    {{ archive_update(target_relation, tmp_relation) }}\n  {% endcall %}\n\n  {% call statement('main') -%}\n\n    insert into {{ target_relation }} (\n      {{ column_list(dest_columns) }}\n    )\n    select {{ column_list(dest_columns) }} from {{ tmp_relation }}\n    where {{ adapter.quote('change_type') }} = 'insert';\n  {% endcall %}\n\n  {{ adapter.commit() }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "materialization_archive_default", "unique_id": "macro.dbt.materialization_archive_default", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.get_merge_sql": {"path": "macros/materializations/common/merge.sql", "original_file_path": "macros/materializations/common/merge.sql", "package_name": "dbt", "raw_sql": "{% macro get_merge_sql(target, source, unique_key, dest_columns) -%}\n  {{ adapter_macro('get_merge_sql', target, source, unique_key, dest_columns) }}\n{%- endmacro %}\n\n\n{% macro common_get_merge_sql(target, source, unique_key, dest_columns) -%}\n    {%- set dest_cols_csv = dest_columns | map(attribute=\"name\") | join(', ') -%}\n\n    merge into {{ target }} as DBT_INTERNAL_DEST\n    using {{ source }} as DBT_INTERNAL_SOURCE\n\n    {% if unique_key %}\n        on DBT_INTERNAL_SOURCE.{{ unique_key }} = DBT_INTERNAL_DEST.{{ unique_key }}\n    {% else %}\n        on FALSE\n    {% endif %}\n\n    {% if unique_key %}\n    when matched then update set\n        {% for column in dest_columns -%}\n            {{ column.name }} = DBT_INTERNAL_SOURCE.{{ column.name }}\n            {%- if not loop.last %}, {%- endif %}\n        {%- endfor %}\n    {% endif %}\n\n    when not matched then insert\n        ({{ dest_cols_csv }})\n    values\n        ({{ dest_cols_csv }})\n\n{% endmacro %}\n\n{% macro default__get_merge_sql(target, source, unique_key, dest_columns) -%}\n    {% set typename = adapter.type() %}\n\n    {{ exceptions.raise_compiler_error(\n        'get_merge_sql is not implemented for {}'.format(typename)\n       )\n    }}\n\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "get_merge_sql", "unique_id": "macro.dbt.get_merge_sql", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.common_get_merge_sql": {"path": "macros/materializations/common/merge.sql", "original_file_path": "macros/materializations/common/merge.sql", "package_name": "dbt", "raw_sql": "{% macro get_merge_sql(target, source, unique_key, dest_columns) -%}\n  {{ adapter_macro('get_merge_sql', target, source, unique_key, dest_columns) }}\n{%- endmacro %}\n\n\n{% macro common_get_merge_sql(target, source, unique_key, dest_columns) -%}\n    {%- set dest_cols_csv = dest_columns | map(attribute=\"name\") | join(', ') -%}\n\n    merge into {{ target }} as DBT_INTERNAL_DEST\n    using {{ source }} as DBT_INTERNAL_SOURCE\n\n    {% if unique_key %}\n        on DBT_INTERNAL_SOURCE.{{ unique_key }} = DBT_INTERNAL_DEST.{{ unique_key }}\n    {% else %}\n        on FALSE\n    {% endif %}\n\n    {% if unique_key %}\n    when matched then update set\n        {% for column in dest_columns -%}\n            {{ column.name }} = DBT_INTERNAL_SOURCE.{{ column.name }}\n            {%- if not loop.last %}, {%- endif %}\n        {%- endfor %}\n    {% endif %}\n\n    when not matched then insert\n        ({{ dest_cols_csv }})\n    values\n        ({{ dest_cols_csv }})\n\n{% endmacro %}\n\n{% macro default__get_merge_sql(target, source, unique_key, dest_columns) -%}\n    {% set typename = adapter.type() %}\n\n    {{ exceptions.raise_compiler_error(\n        'get_merge_sql is not implemented for {}'.format(typename)\n       )\n    }}\n\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "common_get_merge_sql", "unique_id": "macro.dbt.common_get_merge_sql", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__get_merge_sql": {"path": "macros/materializations/common/merge.sql", "original_file_path": "macros/materializations/common/merge.sql", "package_name": "dbt", "raw_sql": "{% macro get_merge_sql(target, source, unique_key, dest_columns) -%}\n  {{ adapter_macro('get_merge_sql', target, source, unique_key, dest_columns) }}\n{%- endmacro %}\n\n\n{% macro common_get_merge_sql(target, source, unique_key, dest_columns) -%}\n    {%- set dest_cols_csv = dest_columns | map(attribute=\"name\") | join(', ') -%}\n\n    merge into {{ target }} as DBT_INTERNAL_DEST\n    using {{ source }} as DBT_INTERNAL_SOURCE\n\n    {% if unique_key %}\n        on DBT_INTERNAL_SOURCE.{{ unique_key }} = DBT_INTERNAL_DEST.{{ unique_key }}\n    {% else %}\n        on FALSE\n    {% endif %}\n\n    {% if unique_key %}\n    when matched then update set\n        {% for column in dest_columns -%}\n            {{ column.name }} = DBT_INTERNAL_SOURCE.{{ column.name }}\n            {%- if not loop.last %}, {%- endif %}\n        {%- endfor %}\n    {% endif %}\n\n    when not matched then insert\n        ({{ dest_cols_csv }})\n    values\n        ({{ dest_cols_csv }})\n\n{% endmacro %}\n\n{% macro default__get_merge_sql(target, source, unique_key, dest_columns) -%}\n    {% set typename = adapter.type() %}\n\n    {{ exceptions.raise_compiler_error(\n        'get_merge_sql is not implemented for {}'.format(typename)\n       )\n    }}\n\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__get_merge_sql", "unique_id": "macro.dbt.default__get_merge_sql", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.materialization_table_default": {"path": "macros/materializations/table/table.sql", "original_file_path": "macros/materializations/table/table.sql", "package_name": "dbt", "raw_sql": "{% materialization table, default %}\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_tmp' -%}\n  {%- set backup_identifier = identifier + '__dbt_backup' -%}\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n  {%- set target_relation = api.Relation.create(identifier=identifier,\n                                                schema=schema,\n                                                database=database,\n                                                type='table') -%}\n  {%- set intermediate_relation = api.Relation.create(identifier=tmp_identifier,\n                                                      schema=schema,\n                                                      database=database,\n                                                      type='table') -%}\n\n  /*\n      See ../view/view.sql for more information about this relation.\n  */\n  {%- set backup_relation = api.Relation.create(identifier=backup_identifier,\n                                                schema=schema,\n                                                database=database,\n                                                type=(old_relation.type or 'table')) -%}\n\n  {%- set exists_as_table = (old_relation is not none and old_relation.is_table) -%}\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n  {%- set create_as_temporary = (exists_as_table and non_destructive_mode) -%}\n\n\n  -- drop the temp relations if they exists for some reason\n  {{ adapter.drop_relation(intermediate_relation) }}\n  {{ adapter.drop_relation(backup_relation) }}\n\n  -- setup: if the target relation already exists, truncate or drop it (if it's a view)\n  {% if non_destructive_mode -%}\n    {% if exists_as_table -%}\n      {{ adapter.truncate_relation(old_relation) }}\n    {% elif exists_as_view -%}\n      {{ adapter.drop_relation(old_relation) }}\n      {%- set old_relation = none -%}\n    {%- endif %}\n  {%- endif %}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% call statement('main') -%}\n    {%- if non_destructive_mode -%}\n      {%- if old_relation is not none -%}\n        {{ create_table_as(create_as_temporary, intermediate_relation, sql) }}\n\n        {% set dest_columns = adapter.get_columns_in_relation(target_relation) %}\n        {% set dest_cols_csv = dest_columns | map(attribute='quoted') | join(', ') %}\n\n        insert into {{ target_relation }} ({{ dest_cols_csv }}) (\n          select {{ dest_cols_csv }}\n          from {{ intermediate_relation.include(database=(not create_as_temporary),\n                                                schema=(not create_as_temporary)) }}\n        );\n      {%- else -%}\n        {{ create_table_as(create_as_temporary, target_relation, sql) }}\n      {%- endif -%}\n    {%- else -%}\n      {{ create_table_as(create_as_temporary, intermediate_relation, sql) }}\n    {%- endif -%}\n  {%- endcall %}\n\n  -- cleanup\n  {% if non_destructive_mode -%}\n    -- noop\n  {%- else -%}\n    {% if old_relation is not none %}\n        {{ adapter.rename_relation(target_relation, backup_relation) }}\n    {% endif %}\n\n    {{ adapter.rename_relation(intermediate_relation, target_relation) }}\n  {%- endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  -- `COMMIT` happens here\n  {{ adapter.commit() }}\n\n  -- finally, drop the existing/backup relation after the commit\n  {{ drop_relation_if_exists(backup_relation) }}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n{% endmaterialization %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "materialization_table_default", "unique_id": "macro.dbt.materialization_table_default", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.materialization_view_default": {"path": "macros/materializations/view/view.sql", "original_file_path": "macros/materializations/view/view.sql", "package_name": "dbt", "raw_sql": "{%- materialization view, default -%}\n\n  {%- set identifier = model['alias'] -%}\n  {%- set tmp_identifier = identifier + '__dbt_tmp' -%}\n  {%- set backup_identifier = identifier + '__dbt_backup' -%}\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n  {%- set target_relation = api.Relation.create(identifier=identifier, schema=schema, database=database,\n                                                type='view') -%}\n  {%- set intermediate_relation = api.Relation.create(identifier=tmp_identifier,\n                                                      schema=schema, database=database, type='view') -%}\n\n  /*\n     This relation (probably) doesn't exist yet. If it does exist, it's a leftover from\n     a previous run, and we're going to try to drop it immediately. At the end of this\n     materialization, we're going to rename the \"old_relation\" to this identifier,\n     and then we're going to drop it. In order to make sure we run the correct one of:\n       - drop view ...\n       - drop table ...\n\n     We need to set the type of this relation to be the type of the old_relation, if it exists,\n     or else \"view\" as a sane default if it does not. Note that if the old_relation does not\n     exist, then there is nothing to move out of the way and subsequentally drop. In that case,\n     this relation will be effectively unused.\n  */\n  {%- set backup_relation = api.Relation.create(identifier=backup_identifier,\n                                                schema=schema, database=database,\n                                                type=(old_relation.type or 'view')) -%}\n\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set has_transactional_hooks = (hooks | selectattr('transaction', 'equalto', True) | list | length) > 0 %}\n  {%- set should_ignore = non_destructive_mode and exists_as_view %}\n\n  {{ run_hooks(pre_hooks, inside_transaction=False) }}\n\n  -- drop the temp relations if they exists for some reason\n  {{ adapter.drop_relation(intermediate_relation) }}\n  {{ adapter.drop_relation(backup_relation) }}\n\n  -- `BEGIN` happens here:\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- build model\n  {% if should_ignore -%}\n    {#\n      -- Materializations need to a statement with name='main'.\n      -- We could issue a no-op query here (like `select 1`), but that's wasteful. Instead:\n      --   1) write the sql contents out to the compiled dirs\n      --   2) return a status and result to the caller\n    #}\n    {% call noop_statement('main', status=\"PASS\", res=None) -%}\n      -- Not running : non-destructive mode\n      {{ sql }}\n    {%- endcall %}\n  {%- else -%}\n    {% call statement('main') -%}\n      {{ create_view_as(intermediate_relation, sql) }}\n    {%- endcall %}\n  {%- endif %}\n\n  -- cleanup\n  {% if not should_ignore -%}\n    -- move the existing view out of the way\n    {% if old_relation is not none %}\n      {{ adapter.rename_relation(target_relation, backup_relation) }}\n    {% endif %}\n    {{ adapter.rename_relation(intermediate_relation, target_relation) }}\n  {%- endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  {#\n      -- Don't commit in non-destructive mode _unless_ there are in-transaction hooks\n      -- TODO : Figure out some other way of doing this that isn't as fragile\n  #}\n  {% if has_transactional_hooks or not should_ignore %}\n      {{ adapter.commit() }}\n  {% endif %}\n\n  {% if not should_ignore %}\n    {{ drop_relation_if_exists(backup_relation) }}\n  {% endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=False) }}\n\n{%- endmaterialization -%}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "materialization_view_default", "unique_id": "macro.dbt.materialization_view_default", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.handle_existing_table": {"path": "macros/materializations/view/create_or_replace_view.sql", "original_file_path": "macros/materializations/view/create_or_replace_view.sql", "package_name": "dbt", "raw_sql": "{% macro handle_existing_table(full_refresh, non_destructive_mode, old_relation) %}\n    {{ adapter_macro(\"dbt.handle_existing_table\", full_refresh, non_destructive_mode, old_relation) }}\n{% endmacro %}\n\n{% macro default__handle_existing_table(full_refresh, non_destructive_mode, old_relation) %}\n    {%- if not non_destructive_mode -%}\n      {{ adapter.drop_relation(old_relation) }}\n    {%- endif -%}\n{% endmacro %}\n\n{# /*\n       Core materialization implementation. BigQuery and Snowflake are similar\n       because both can use `create or replace view` where the resulting view schema\n       is not necessarily the same as the existing view. On Redshift, this would\n       result in: ERROR:  cannot change number of columns in view\n\n       This implementation is superior to the create_temp, swap_with_existing, drop_old\n       paradigm because transactions don't run DDL queries atomically on Snowflake. By using\n       `create or replace view`, the materialization becomes atomic in nature.\n    */\n#}\n\n{% macro create_or_replace_view(run_outside_transaction_hooks=True) %}\n  {%- set identifier = model['alias'] -%}\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set target_relation = api.Relation.create(\n      identifier=identifier, schema=schema, database=database,\n      type='view') -%}\n\n  {%- set should_ignore = non_destructive_mode and exists_as_view %}\n  {%- set has_transactional_hooks = (hooks | selectattr('transaction', 'equalto', True) | list | length) > 0 %}\n\n  {% if run_outside_transaction_hooks %}\n      -- no transactions on BigQuery\n      {{ run_hooks(pre_hooks, inside_transaction=False) }}\n  {% endif %}\n\n  -- `BEGIN` happens here on Snowflake\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- If there's a table with the same name and we weren't told to full refresh,\n  -- that's an error. If we were told to full refresh, drop it. This behavior differs\n  -- for Snowflake and BigQuery, so multiple dispatch is used.\n  {%- if old_relation is not none and old_relation.is_table -%}\n    {{ handle_existing_table(flags.FULL_REFRESH, non_destructive_mode, old_relation) }}\n  {%- endif -%}\n\n  -- build model\n  {% if non_destructive_mode -%}\n    {% call noop_statement('main', status=\"PASS\", res=None) -%}\n      -- Not running : non-destructive mode\n      {{ sql }}\n    {%- endcall %}\n  {%- else -%}\n    {% call statement('main') -%}\n      {{ create_view_as(target_relation, sql) }}\n    {%- endcall %}\n  {%- endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  {#\n      -- Don't commit in non-destructive mode _unless_ there are in-transaction hooks\n      -- TODO : Figure out some other way of doing this that isn't as fragile\n  #}\n  {% if has_transactional_hooks or not should_ignore %}\n      {{ adapter.commit() }}\n  {% endif %}\n\n  {% if run_outside_transaction_hooks %}\n      -- No transactions on BigQuery\n      {{ run_hooks(post_hooks, inside_transaction=False) }}\n  {% endif %}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "handle_existing_table", "unique_id": "macro.dbt.handle_existing_table", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__handle_existing_table": {"path": "macros/materializations/view/create_or_replace_view.sql", "original_file_path": "macros/materializations/view/create_or_replace_view.sql", "package_name": "dbt", "raw_sql": "{% macro handle_existing_table(full_refresh, non_destructive_mode, old_relation) %}\n    {{ adapter_macro(\"dbt.handle_existing_table\", full_refresh, non_destructive_mode, old_relation) }}\n{% endmacro %}\n\n{% macro default__handle_existing_table(full_refresh, non_destructive_mode, old_relation) %}\n    {%- if not non_destructive_mode -%}\n      {{ adapter.drop_relation(old_relation) }}\n    {%- endif -%}\n{% endmacro %}\n\n{# /*\n       Core materialization implementation. BigQuery and Snowflake are similar\n       because both can use `create or replace view` where the resulting view schema\n       is not necessarily the same as the existing view. On Redshift, this would\n       result in: ERROR:  cannot change number of columns in view\n\n       This implementation is superior to the create_temp, swap_with_existing, drop_old\n       paradigm because transactions don't run DDL queries atomically on Snowflake. By using\n       `create or replace view`, the materialization becomes atomic in nature.\n    */\n#}\n\n{% macro create_or_replace_view(run_outside_transaction_hooks=True) %}\n  {%- set identifier = model['alias'] -%}\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set target_relation = api.Relation.create(\n      identifier=identifier, schema=schema, database=database,\n      type='view') -%}\n\n  {%- set should_ignore = non_destructive_mode and exists_as_view %}\n  {%- set has_transactional_hooks = (hooks | selectattr('transaction', 'equalto', True) | list | length) > 0 %}\n\n  {% if run_outside_transaction_hooks %}\n      -- no transactions on BigQuery\n      {{ run_hooks(pre_hooks, inside_transaction=False) }}\n  {% endif %}\n\n  -- `BEGIN` happens here on Snowflake\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- If there's a table with the same name and we weren't told to full refresh,\n  -- that's an error. If we were told to full refresh, drop it. This behavior differs\n  -- for Snowflake and BigQuery, so multiple dispatch is used.\n  {%- if old_relation is not none and old_relation.is_table -%}\n    {{ handle_existing_table(flags.FULL_REFRESH, non_destructive_mode, old_relation) }}\n  {%- endif -%}\n\n  -- build model\n  {% if non_destructive_mode -%}\n    {% call noop_statement('main', status=\"PASS\", res=None) -%}\n      -- Not running : non-destructive mode\n      {{ sql }}\n    {%- endcall %}\n  {%- else -%}\n    {% call statement('main') -%}\n      {{ create_view_as(target_relation, sql) }}\n    {%- endcall %}\n  {%- endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  {#\n      -- Don't commit in non-destructive mode _unless_ there are in-transaction hooks\n      -- TODO : Figure out some other way of doing this that isn't as fragile\n  #}\n  {% if has_transactional_hooks or not should_ignore %}\n      {{ adapter.commit() }}\n  {% endif %}\n\n  {% if run_outside_transaction_hooks %}\n      -- No transactions on BigQuery\n      {{ run_hooks(post_hooks, inside_transaction=False) }}\n  {% endif %}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__handle_existing_table", "unique_id": "macro.dbt.default__handle_existing_table", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.create_or_replace_view": {"path": "macros/materializations/view/create_or_replace_view.sql", "original_file_path": "macros/materializations/view/create_or_replace_view.sql", "package_name": "dbt", "raw_sql": "{% macro handle_existing_table(full_refresh, non_destructive_mode, old_relation) %}\n    {{ adapter_macro(\"dbt.handle_existing_table\", full_refresh, non_destructive_mode, old_relation) }}\n{% endmacro %}\n\n{% macro default__handle_existing_table(full_refresh, non_destructive_mode, old_relation) %}\n    {%- if not non_destructive_mode -%}\n      {{ adapter.drop_relation(old_relation) }}\n    {%- endif -%}\n{% endmacro %}\n\n{# /*\n       Core materialization implementation. BigQuery and Snowflake are similar\n       because both can use `create or replace view` where the resulting view schema\n       is not necessarily the same as the existing view. On Redshift, this would\n       result in: ERROR:  cannot change number of columns in view\n\n       This implementation is superior to the create_temp, swap_with_existing, drop_old\n       paradigm because transactions don't run DDL queries atomically on Snowflake. By using\n       `create or replace view`, the materialization becomes atomic in nature.\n    */\n#}\n\n{% macro create_or_replace_view(run_outside_transaction_hooks=True) %}\n  {%- set identifier = model['alias'] -%}\n  {%- set non_destructive_mode = (flags.NON_DESTRUCTIVE == True) -%}\n\n  {%- set old_relation = adapter.get_relation(database=database, schema=schema, identifier=identifier) -%}\n\n  {%- set exists_as_view = (old_relation is not none and old_relation.is_view) -%}\n\n  {%- set target_relation = api.Relation.create(\n      identifier=identifier, schema=schema, database=database,\n      type='view') -%}\n\n  {%- set should_ignore = non_destructive_mode and exists_as_view %}\n  {%- set has_transactional_hooks = (hooks | selectattr('transaction', 'equalto', True) | list | length) > 0 %}\n\n  {% if run_outside_transaction_hooks %}\n      -- no transactions on BigQuery\n      {{ run_hooks(pre_hooks, inside_transaction=False) }}\n  {% endif %}\n\n  -- `BEGIN` happens here on Snowflake\n  {{ run_hooks(pre_hooks, inside_transaction=True) }}\n\n  -- If there's a table with the same name and we weren't told to full refresh,\n  -- that's an error. If we were told to full refresh, drop it. This behavior differs\n  -- for Snowflake and BigQuery, so multiple dispatch is used.\n  {%- if old_relation is not none and old_relation.is_table -%}\n    {{ handle_existing_table(flags.FULL_REFRESH, non_destructive_mode, old_relation) }}\n  {%- endif -%}\n\n  -- build model\n  {% if non_destructive_mode -%}\n    {% call noop_statement('main', status=\"PASS\", res=None) -%}\n      -- Not running : non-destructive mode\n      {{ sql }}\n    {%- endcall %}\n  {%- else -%}\n    {% call statement('main') -%}\n      {{ create_view_as(target_relation, sql) }}\n    {%- endcall %}\n  {%- endif %}\n\n  {{ run_hooks(post_hooks, inside_transaction=True) }}\n\n  {#\n      -- Don't commit in non-destructive mode _unless_ there are in-transaction hooks\n      -- TODO : Figure out some other way of doing this that isn't as fragile\n  #}\n  {% if has_transactional_hooks or not should_ignore %}\n      {{ adapter.commit() }}\n  {% endif %}\n\n  {% if run_outside_transaction_hooks %}\n      -- No transactions on BigQuery\n      {{ run_hooks(post_hooks, inside_transaction=False) }}\n  {% endif %}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "create_or_replace_view", "unique_id": "macro.dbt.create_or_replace_view", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.is_incremental": {"path": "macros/etc/is_incremental.sql", "original_file_path": "macros/etc/is_incremental.sql", "package_name": "dbt", "raw_sql": "{% macro is_incremental() %}\n    {#-- do not run introspective queries in parsing #}\n    {% if not execute %}\n        {{ return(False) }}\n    {% else %}\n        {% set relation = adapter.get_relation(this.database, this.schema, this.table) %}\n        {{ return(relation is not none and relation.type == 'table' and not flags.FULL_REFRESH) }}\n    {% endif %}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "is_incremental", "unique_id": "macro.dbt.is_incremental", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.convert_datetime": {"path": "macros/etc/datetime.sql", "original_file_path": "macros/etc/datetime.sql", "package_name": "dbt", "raw_sql": "{% macro convert_datetime(date_str, date_fmt) %}\n\n  {% set error_msg -%}\n      The provided partition date '{{ date_str }}' does not match the expected format '{{ date_fmt }}'\n  {%- endset %}\n\n  {% set res = try_or_compiler_error(error_msg, modules.datetime.datetime.strptime, date_str.strip(), date_fmt) %}\n  {{ return(res) }}\n\n{% endmacro %}\n\n{% macro dates_in_range(start_date_str, end_date_str=none, in_fmt=\"%Y%m%d\", out_fmt=\"%Y%m%d\") %}\n    {% set end_date_str = start_date_str if end_date_str is none else end_date_str %}\n\n    {% set start_date = convert_datetime(start_date_str, in_fmt) %}\n    {% set end_date = convert_datetime(end_date_str, in_fmt) %}\n\n    {% set day_count = (end_date - start_date).days %}\n    {% if day_count < 0 %}\n        {% set msg -%}\n            Partiton start date is after the end date ({{ start_date }}, {{ end_date }})\n        {%- endset %}\n\n        {{ exceptions.raise_compiler_error(msg, model) }}\n    {% endif %}\n\n    {% set date_list = [] %}\n    {% for i in range(0, day_count + 1) %}\n        {% set the_date = (modules.datetime.timedelta(days=i) + start_date) %}\n        {% if not out_fmt %}\n            {% set _ = date_list.append(the_date) %}\n        {% else %}\n            {% set _ = date_list.append(the_date.strftime(out_fmt)) %}\n        {% endif %}\n    {% endfor %}\n\n    {{ return(date_list) }}\n{% endmacro %}\n\n{% macro partition_range(raw_partition_date, date_fmt='%Y%m%d') %}\n    {% set partition_range = (raw_partition_date | string).split(\",\") %}\n\n    {% if (partition_range | length) == 1 %}\n      {% set start_date = partition_range[0] %}\n      {% set end_date = none %}\n    {% elif (partition_range | length) == 2 %}\n      {% set start_date = partition_range[0] %}\n      {% set end_date = partition_range[1] %}\n    {% else %}\n      {{ dbt.exceptions.raise_compiler_error(\"Invalid partition time. Expected format: {Start Date}[,{End Date}]. Got: \" ~ raw_partition_date) }}\n    {% endif %}\n\n    {{ return(dates_in_range(start_date, end_date, in_fmt=date_fmt)) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "convert_datetime", "unique_id": "macro.dbt.convert_datetime", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.dates_in_range": {"path": "macros/etc/datetime.sql", "original_file_path": "macros/etc/datetime.sql", "package_name": "dbt", "raw_sql": "{% macro convert_datetime(date_str, date_fmt) %}\n\n  {% set error_msg -%}\n      The provided partition date '{{ date_str }}' does not match the expected format '{{ date_fmt }}'\n  {%- endset %}\n\n  {% set res = try_or_compiler_error(error_msg, modules.datetime.datetime.strptime, date_str.strip(), date_fmt) %}\n  {{ return(res) }}\n\n{% endmacro %}\n\n{% macro dates_in_range(start_date_str, end_date_str=none, in_fmt=\"%Y%m%d\", out_fmt=\"%Y%m%d\") %}\n    {% set end_date_str = start_date_str if end_date_str is none else end_date_str %}\n\n    {% set start_date = convert_datetime(start_date_str, in_fmt) %}\n    {% set end_date = convert_datetime(end_date_str, in_fmt) %}\n\n    {% set day_count = (end_date - start_date).days %}\n    {% if day_count < 0 %}\n        {% set msg -%}\n            Partiton start date is after the end date ({{ start_date }}, {{ end_date }})\n        {%- endset %}\n\n        {{ exceptions.raise_compiler_error(msg, model) }}\n    {% endif %}\n\n    {% set date_list = [] %}\n    {% for i in range(0, day_count + 1) %}\n        {% set the_date = (modules.datetime.timedelta(days=i) + start_date) %}\n        {% if not out_fmt %}\n            {% set _ = date_list.append(the_date) %}\n        {% else %}\n            {% set _ = date_list.append(the_date.strftime(out_fmt)) %}\n        {% endif %}\n    {% endfor %}\n\n    {{ return(date_list) }}\n{% endmacro %}\n\n{% macro partition_range(raw_partition_date, date_fmt='%Y%m%d') %}\n    {% set partition_range = (raw_partition_date | string).split(\",\") %}\n\n    {% if (partition_range | length) == 1 %}\n      {% set start_date = partition_range[0] %}\n      {% set end_date = none %}\n    {% elif (partition_range | length) == 2 %}\n      {% set start_date = partition_range[0] %}\n      {% set end_date = partition_range[1] %}\n    {% else %}\n      {{ dbt.exceptions.raise_compiler_error(\"Invalid partition time. Expected format: {Start Date}[,{End Date}]. Got: \" ~ raw_partition_date) }}\n    {% endif %}\n\n    {{ return(dates_in_range(start_date, end_date, in_fmt=date_fmt)) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "dates_in_range", "unique_id": "macro.dbt.dates_in_range", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.partition_range": {"path": "macros/etc/datetime.sql", "original_file_path": "macros/etc/datetime.sql", "package_name": "dbt", "raw_sql": "{% macro convert_datetime(date_str, date_fmt) %}\n\n  {% set error_msg -%}\n      The provided partition date '{{ date_str }}' does not match the expected format '{{ date_fmt }}'\n  {%- endset %}\n\n  {% set res = try_or_compiler_error(error_msg, modules.datetime.datetime.strptime, date_str.strip(), date_fmt) %}\n  {{ return(res) }}\n\n{% endmacro %}\n\n{% macro dates_in_range(start_date_str, end_date_str=none, in_fmt=\"%Y%m%d\", out_fmt=\"%Y%m%d\") %}\n    {% set end_date_str = start_date_str if end_date_str is none else end_date_str %}\n\n    {% set start_date = convert_datetime(start_date_str, in_fmt) %}\n    {% set end_date = convert_datetime(end_date_str, in_fmt) %}\n\n    {% set day_count = (end_date - start_date).days %}\n    {% if day_count < 0 %}\n        {% set msg -%}\n            Partiton start date is after the end date ({{ start_date }}, {{ end_date }})\n        {%- endset %}\n\n        {{ exceptions.raise_compiler_error(msg, model) }}\n    {% endif %}\n\n    {% set date_list = [] %}\n    {% for i in range(0, day_count + 1) %}\n        {% set the_date = (modules.datetime.timedelta(days=i) + start_date) %}\n        {% if not out_fmt %}\n            {% set _ = date_list.append(the_date) %}\n        {% else %}\n            {% set _ = date_list.append(the_date.strftime(out_fmt)) %}\n        {% endif %}\n    {% endfor %}\n\n    {{ return(date_list) }}\n{% endmacro %}\n\n{% macro partition_range(raw_partition_date, date_fmt='%Y%m%d') %}\n    {% set partition_range = (raw_partition_date | string).split(\",\") %}\n\n    {% if (partition_range | length) == 1 %}\n      {% set start_date = partition_range[0] %}\n      {% set end_date = none %}\n    {% elif (partition_range | length) == 2 %}\n      {% set start_date = partition_range[0] %}\n      {% set end_date = partition_range[1] %}\n    {% else %}\n      {{ dbt.exceptions.raise_compiler_error(\"Invalid partition time. Expected format: {Start Date}[,{End Date}]. Got: \" ~ raw_partition_date) }}\n    {% endif %}\n\n    {{ return(dates_in_range(start_date, end_date, in_fmt=date_fmt)) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "partition_range", "unique_id": "macro.dbt.partition_range", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.generate_schema_name": {"path": "macros/etc/get_custom_schema.sql", "original_file_path": "macros/etc/get_custom_schema.sql", "package_name": "dbt", "raw_sql": "{#\n    Renders a schema name given a custom schema name. If the custom\n    schema name is none, then the resulting schema is just the \"schema\"\n    value in the specified target. If a schema override is specified, then\n    the resulting schema is the default schema concatenated with the \n    custom schema.\n\n    This macro can be overriden in projects to define different semantics\n    for rendering a schema name.\n\n    Arguments:\n    custom_schema_name: The custom schema name specified for a model, or none\n\n#}\n{% macro generate_schema_name(custom_schema_name=none) -%}\n\n    {%- set default_schema = target.schema -%}\n    {%- if custom_schema_name is none -%}\n\n        {{ default_schema }}\n\n    {%- else -%}\n\n        {{ default_schema }}_{{ custom_schema_name | trim }}\n\n    {%- endif -%}\n\n{%- endmacro %}\n\n\n{#\n    Renders a schema name given a custom schema name. In production, this macro\n    will render out the overriden schema name for a model. Otherwise, the default\n    schema specified in the active target is used.\n\n    Arguments:\n    custom_schema_name: The custom schema name specified for a model, or none\n\n#}\n{% macro generate_schema_name_for_env(custom_schema_name=none) -%}\n\n    {%- set default_schema = target.schema -%}\n    {%- if target.name == 'prod' and custom_schema_name is not none -%}\n\n        {{ custom_schema_name | trim }}\n\n    {%- else -%}\n\n        {{ default_schema }}\n\n    {%- endif -%}\n\n{%- endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "generate_schema_name", "unique_id": "macro.dbt.generate_schema_name", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.generate_schema_name_for_env": {"path": "macros/etc/get_custom_schema.sql", "original_file_path": "macros/etc/get_custom_schema.sql", "package_name": "dbt", "raw_sql": "{#\n    Renders a schema name given a custom schema name. If the custom\n    schema name is none, then the resulting schema is just the \"schema\"\n    value in the specified target. If a schema override is specified, then\n    the resulting schema is the default schema concatenated with the \n    custom schema.\n\n    This macro can be overriden in projects to define different semantics\n    for rendering a schema name.\n\n    Arguments:\n    custom_schema_name: The custom schema name specified for a model, or none\n\n#}\n{% macro generate_schema_name(custom_schema_name=none) -%}\n\n    {%- set default_schema = target.schema -%}\n    {%- if custom_schema_name is none -%}\n\n        {{ default_schema }}\n\n    {%- else -%}\n\n        {{ default_schema }}_{{ custom_schema_name | trim }}\n\n    {%- endif -%}\n\n{%- endmacro %}\n\n\n{#\n    Renders a schema name given a custom schema name. In production, this macro\n    will render out the overriden schema name for a model. Otherwise, the default\n    schema specified in the active target is used.\n\n    Arguments:\n    custom_schema_name: The custom schema name specified for a model, or none\n\n#}\n{% macro generate_schema_name_for_env(custom_schema_name=none) -%}\n\n    {%- set default_schema = target.schema -%}\n    {%- if target.name == 'prod' and custom_schema_name is not none -%}\n\n        {{ custom_schema_name | trim }}\n\n    {%- else -%}\n\n        {{ default_schema }}\n\n    {%- endif -%}\n\n{%- endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "generate_schema_name_for_env", "unique_id": "macro.dbt.generate_schema_name_for_env", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.adapter_macro": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "adapter_macro", "unique_id": "macro.dbt.adapter_macro", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.create_schema": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "create_schema", "unique_id": "macro.dbt.create_schema", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__create_schema": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__create_schema", "unique_id": "macro.dbt.default__create_schema", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.drop_schema": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "drop_schema", "unique_id": "macro.dbt.drop_schema", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__drop_schema": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__drop_schema", "unique_id": "macro.dbt.default__drop_schema", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.create_table_as": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "create_table_as", "unique_id": "macro.dbt.create_table_as", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__create_table_as": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__create_table_as", "unique_id": "macro.dbt.default__create_table_as", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.create_view_as": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "create_view_as", "unique_id": "macro.dbt.create_view_as", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__create_view_as": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__create_view_as", "unique_id": "macro.dbt.default__create_view_as", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.create_archive_table": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "create_archive_table", "unique_id": "macro.dbt.create_archive_table", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__create_archive_table": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__create_archive_table", "unique_id": "macro.dbt.default__create_archive_table", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.get_catalog": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "get_catalog", "unique_id": "macro.dbt.get_catalog", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__get_catalog": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__get_catalog", "unique_id": "macro.dbt.default__get_catalog", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.get_columns_in_relation": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "get_columns_in_relation", "unique_id": "macro.dbt.get_columns_in_relation", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.sql_convert_columns_in_relation": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "sql_convert_columns_in_relation", "unique_id": "macro.dbt.sql_convert_columns_in_relation", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__get_columns_in_relation": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__get_columns_in_relation", "unique_id": "macro.dbt.default__get_columns_in_relation", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.alter_column_type": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "alter_column_type", "unique_id": "macro.dbt.alter_column_type", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__alter_column_type": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__alter_column_type", "unique_id": "macro.dbt.default__alter_column_type", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.drop_relation": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "drop_relation", "unique_id": "macro.dbt.drop_relation", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__drop_relation": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__drop_relation", "unique_id": "macro.dbt.default__drop_relation", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.truncate_relation": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "truncate_relation", "unique_id": "macro.dbt.truncate_relation", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__truncate_relation": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__truncate_relation", "unique_id": "macro.dbt.default__truncate_relation", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.rename_relation": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "rename_relation", "unique_id": "macro.dbt.rename_relation", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__rename_relation": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__rename_relation", "unique_id": "macro.dbt.default__rename_relation", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.information_schema_name": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "information_schema_name", "unique_id": "macro.dbt.information_schema_name", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__information_schema_name": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__information_schema_name", "unique_id": "macro.dbt.default__information_schema_name", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.list_schemas": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "list_schemas", "unique_id": "macro.dbt.list_schemas", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__list_schemas": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__list_schemas", "unique_id": "macro.dbt.default__list_schemas", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.check_schema_exists": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "check_schema_exists", "unique_id": "macro.dbt.check_schema_exists", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__check_schema_exists": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__check_schema_exists", "unique_id": "macro.dbt.default__check_schema_exists", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.list_relations_without_caching": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "list_relations_without_caching", "unique_id": "macro.dbt.list_relations_without_caching", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__list_relations_without_caching": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__list_relations_without_caching", "unique_id": "macro.dbt.default__list_relations_without_caching", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.current_timestamp": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "current_timestamp", "unique_id": "macro.dbt.current_timestamp", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__current_timestamp": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__current_timestamp", "unique_id": "macro.dbt.default__current_timestamp", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.collect_freshness": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "collect_freshness", "unique_id": "macro.dbt.collect_freshness", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.default__collect_freshness": {"path": "macros/adapters/common.sql", "original_file_path": "macros/adapters/common.sql", "package_name": "dbt", "raw_sql": "{% macro adapter_macro(name) -%}\n{% set original_name = name %}\n  {% if '.' in name %}\n    {% set package_name, name = name.split(\".\", 1) %}\n  {% else %}\n    {% set package_name = none %}\n  {% endif %}\n\n  {% if package_name is none %}\n    {% set package_context = context %}\n  {% elif package_name in context %}\n    {% set package_context = context[package_name] %}\n  {% else %}\n    {% set error_msg %}\n        In adapter_macro: could not find package '{{package_name}}', called with '{{original_name}}'\n    {% endset %}\n    {{ exceptions.raise_compiler_error(error_msg | trim) }}\n  {% endif %}\n\n  {%- set separator = '__' -%}\n  {%- set search_name = adapter.type() + separator + name -%}\n  {%- set default_name = 'default' + separator + name -%}\n\n  {%- if package_context.get(search_name) is not none -%}\n    {{ return(package_context[search_name](*varargs, **kwargs)) }}\n  {%- else -%}\n    {{ return(package_context[default_name](*varargs, **kwargs)) }}\n  {%- endif -%}\n{%- endmacro %}\n\n{% macro create_schema(database_name, schema_name) -%}\n  {{ adapter_macro('create_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__create_schema(database_name, schema_name) -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{database_name}}.{{schema_name}}\n  {% endcall %}\n{% endmacro %}\n\n{% macro drop_schema(database_name, schema_name) -%}\n  {{ adapter_macro('drop_schema', database_name, schema_name) }}\n{% endmacro %}\n\n{% macro default__drop_schema(database_name, schema_name) -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{database_name}}.{{schema_name}} cascade\n  {% endcall %}\n{% endmacro %}\n\n{% macro create_table_as(temporary, relation, sql) -%}\n  {{ adapter_macro('create_table_as', temporary, relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_table_as(temporary, relation, sql) -%}\n  create {% if temporary: -%}temporary{%- endif %} table\n    {{ relation.include(database=(not temporary), schema=(not temporary)) }}\n  as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_view_as(relation, sql) -%}\n  {{ adapter_macro('create_view_as', relation, sql) }}\n{%- endmacro %}\n\n{% macro default__create_view_as(relation, sql) -%}\n  create view {{ relation }} as (\n    {{ sql }}\n  );\n{% endmacro %}\n\n\n{% macro create_archive_table(relation, columns) -%}\n  {{ adapter_macro('create_archive_table', relation, columns) }}\n{%- endmacro %}\n\n{% macro default__create_archive_table(relation, columns) -%}\n  create table if not exists {{ relation }} (\n    {{ column_list_for_create_table(columns) }}\n  );\n{% endmacro %}\n\n\n{% macro get_catalog(information_schemas) -%}\n  {{ return(adapter_macro('get_catalog', information_schemas)) }}\n{%- endmacro %}\n\n{% macro default__get_catalog(information_schemas) -%}\n\n  {% set typename = adapter.type() %}\n  {% set msg -%}\n    get_catalog not implemented for {{ typename }}\n  {%- endset %}\n\n  {{ exceptions.raise_compiler_error(msg) }}\n{% endmacro %}\n\n\n{% macro get_columns_in_relation(relation) -%}\n  {{ return(adapter_macro('get_columns_in_relation', relation)) }}\n{% endmacro %}\n\n{% macro sql_convert_columns_in_relation(table) -%}\n  {% set columns = [] %}\n  {% for row in table %}\n    {% do columns.append(api.Column(*row)) %}\n  {% endfor %}\n  {{ return(columns) }}\n{% endmacro %}\n\n{% macro default__get_columns_in_relation(relation) -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'get_columns_in_relation macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n{% macro alter_column_type(relation, column_name, new_column_type) -%}\n  {{ return(adapter_macro('alter_column_type', relation, column_name, new_column_type)) }}\n{% endmacro %}\n\n{% macro default__alter_column_type(relation, column_name, new_column_type) -%}\n  {#\n    1. Create a new column (w/ temp name and correct type)\n    2. Copy data over to it\n    3. Drop the existing column (cascade!)\n    4. Rename the new column to existing column\n  #}\n  {%- set tmp_column = column_name + \"__dbt_alter\" -%}\n\n  {% call statement('alter_column_type') %}\n    alter table {{ relation }} add column {{ tmp_column }} {{ new_column_type }};\n    update {{ relation }} set {{ tmp_column }} = {{ column_name }};\n    alter table {{ relation }} drop column {{ column_name }} cascade;\n    alter table {{ relation }} rename column {{ tmp_column }} to {{ column_name }}\n  {% endcall %}\n\n{% endmacro %}\n\n\n{% macro drop_relation(relation) -%}\n  {{ return(adapter_macro('drop_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__drop_relation(relation) -%}\n  {% call statement('drop_relation', auto_begin=False) -%}\n    drop {{ relation.type }} if exists {{ relation }} cascade\n  {%- endcall %}\n{% endmacro %}\n\n{% macro truncate_relation(relation) -%}\n  {{ return(adapter_macro('truncate_relation', relation)) }}\n{% endmacro %}\n\n\n{% macro default__truncate_relation(relation) -%}\n  {% call statement('truncate_relation') -%}\n    truncate table {{ relation }}\n  {%- endcall %}\n{% endmacro %}\n\n{% macro rename_relation(from_relation, to_relation) -%}\n  {{ return(adapter_macro('rename_relation', from_relation, to_relation)) }}\n{% endmacro %}\n\n{% macro default__rename_relation(from_relation, to_relation) -%}\n  {% set target_name = adapter.quote_as_configured(to_relation.identifier, 'identifier') %}\n  {% call statement('rename_relation') -%}\n    alter table {{ from_relation }} rename to {{ target_name }}\n  {%- endcall %}\n{% endmacro %}\n\n\n{% macro information_schema_name(database) %}\n  {{ return(adapter_macro('information_schema_name', database)) }}\n{% endmacro %}\n\n{% macro default__information_schema_name(database) -%}\n  {%- if database -%}\n    {{ adapter.quote_as_configured(database, 'database') }}.information_schema\n  {%- else -%}\n    information_schema\n  {%- endif -%}\n{%- endmacro %}\n\n\n{% macro list_schemas(database) -%}\n  {{ return(adapter_macro('list_schemas', database)) }}\n{% endmacro %}\n\n{% macro default__list_schemas(database) -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct schema_name\n    from {{ information_schema_name(database) }}.schemata\n    where catalog_name ilike '{{ database }}'\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n\n{% macro check_schema_exists(information_schema, schema) -%}\n  {{ return(adapter_macro('check_schema_exists', information_schema, schema)) }}\n{% endmacro %}\n\n{% macro default__check_schema_exists(information_schema, schema) -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n        select count(*)\n        from {{ information_schema }}.schemata\n        where catalog_name='{{ information_schema.database }}'\n          and schema_name='{{ schema }}'\n  {%- endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro list_relations_without_caching(information_schema, schema) %}\n  {{ return(adapter_macro('list_relations_without_caching', information_schema, schema)) }}\n{% endmacro %}\n\n\n{% macro default__list_relations_without_caching(information_schema, schema) %}\n  {{ dbt.exceptions.raise_not_implemented(\n    'list_relations_without_caching macro not implemented for adapter '+adapter.type()) }}\n{% endmacro %}\n\n\n{% macro current_timestamp() -%}\n  {{ adapter_macro('current_timestamp') }}\n{%- endmacro %}\n\n\n{% macro default__current_timestamp() -%}\n  {{ dbt.exceptions.raise_not_implemented(\n    'current_timestamp macro not implemented for adapter '+adapter.type()) }}\n{%- endmacro %}\n\n\n{% macro collect_freshness(source, loaded_at_field) %}\n  {{ return(adapter_macro('collect_freshness', source, loaded_at_field))}}\n{% endmacro %}\n\n\n{% macro default__collect_freshness(source, loaded_at_field) %}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) -%}\n    select\n      max({{ loaded_at_field }}) as max_loaded_at,\n      {{ current_timestamp() }} as snapshotted_at\n    from {{ source }}\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "default__collect_freshness", "unique_id": "macro.dbt.default__collect_freshness", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.test_relationships": {"path": "macros/schema_tests/relationships.sql", "original_file_path": "macros/schema_tests/relationships.sql", "package_name": "dbt", "raw_sql": "{% macro test_relationships(model, to, field) %}\n\n{% set column_name = kwargs.get('column_name', kwargs.get('from')) %}\n\n\nselect count(*)\nfrom (\n    select {{ column_name }} as id from {{ model }}\n) as child\nleft join (\n    select {{ field }} as id from {{ to }}\n) as parent on parent.id = child.id\nwhere child.id is not null\n  and parent.id is null\n\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "test_relationships", "unique_id": "macro.dbt.test_relationships", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.test_not_null": {"path": "macros/schema_tests/not_null.sql", "original_file_path": "macros/schema_tests/not_null.sql", "package_name": "dbt", "raw_sql": "{% macro test_not_null(model) %}\n\n{% set column_name = kwargs.get('column_name', kwargs.get('arg')) %}\n\nselect count(*)\nfrom {{ model }}\nwhere {{ column_name }} is null\n\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "test_not_null", "unique_id": "macro.dbt.test_not_null", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.test_unique": {"path": "macros/schema_tests/unique.sql", "original_file_path": "macros/schema_tests/unique.sql", "package_name": "dbt", "raw_sql": "{% macro test_unique(model) %}\n\n{% set column_name = kwargs.get('column_name', kwargs.get('arg')) %}\n\nselect count(*)\nfrom (\n\n    select\n        {{ column_name }}\n\n    from {{ model }}\n    where {{ column_name }} is not null\n    group by {{ column_name }}\n    having count(*) > 1\n\n) validation_errors\n\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "test_unique", "unique_id": "macro.dbt.test_unique", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt.test_accepted_values": {"path": "macros/schema_tests/accepted_values.sql", "original_file_path": "macros/schema_tests/accepted_values.sql", "package_name": "dbt", "raw_sql": "{% macro test_accepted_values(model, values) %}\n\n{% set column_name = kwargs.get('column_name', kwargs.get('field')) %}\n\nwith all_values as (\n\n    select distinct\n        {{ column_name }} as value_field\n\n    from {{ model }}\n\n),\n\nvalidation_errors as (\n\n    select\n        value_field\n\n    from all_values\n    where value_field not in (\n        {% for value in values -%}\n\n            '{{ value }}' {% if not loop.last -%} , {%- endif %}\n\n        {%- endfor %}\n    )\n)\n\nselect count(*)\nfrom validation_errors\n\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "name": "test_accepted_values", "unique_id": "macro.dbt.test_accepted_values", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt_postgres.postgres__get_catalog": {"path": "macros/catalog.sql", "original_file_path": "macros/catalog.sql", "package_name": "dbt_postgres", "raw_sql": "{% macro postgres__get_catalog(information_schemas) -%}\n\n  {%- call statement('catalog', fetch_result=True) -%}\n    {% if (information_schemas | length) != 1 %}\n        {{ exceptions.raise_compiler_error('postgres get_catalog requires exactly one database') }}\n    {% endif %}\n    {% set database = information_schemas[0].database %}\n    {{ adapter.verify_database(database) }}\n\n    with table_owners as (\n\n        select\n            '{{ database }}' as table_database,\n            schemaname as table_schema,\n            tablename as table_name,\n            tableowner as table_owner\n\n        from pg_tables\n\n        union all\n\n        select\n            '{{ database }}' as table_database,\n            schemaname as table_schema,\n            viewname as table_name,\n            viewowner as table_owner\n\n        from pg_views\n\n    ),\n\n    tables as (\n\n        select\n            table_catalog as table_database,\n            table_schema,\n            table_name,\n            table_type\n\n        from information_schema.tables\n\n    ),\n\n    columns as (\n\n        select\n            table_catalog as table_database,\n            table_schema,\n            table_name,\n            null as table_comment,\n            column_name,\n            ordinal_position as column_index,\n            data_type as column_type,\n            null as column_comment\n\n        from information_schema.columns\n\n    )\n\n    select *\n    from tables\n    join columns using (table_database, table_schema, table_name)\n    join table_owners using (table_database, table_schema, table_name)\n\n    where table_schema != 'information_schema'\n      and table_schema not like 'pg_%'\n\n    order by column_index\n\n  {%- endcall -%}\n\n  {{ return(load_result('catalog').table) }}\n\n{%- endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/postgres", "name": "postgres__get_catalog", "unique_id": "macro.dbt_postgres.postgres__get_catalog", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt_postgres.postgres_get_relations": {"path": "macros/relations.sql", "original_file_path": "macros/relations.sql", "package_name": "dbt_postgres", "raw_sql": "{% macro postgres_get_relations () -%}\n  {%- call statement('relations', fetch_result=True) -%}\n    -- {#\n    -- in pg_depend, objid is the dependent, refobjid is the referenced object\n    -- \"a pg_depend entry indicates that the referenced object cannot be dropped without also dropping the dependent object.\"\n    -- #}\n    -- {# this only works with the current database #}\n    with relation as (\n        select\n            pg_rewrite.ev_class as class,\n            pg_rewrite.oid as id\n        from pg_rewrite\n    ),\n    class as (\n        select\n            oid as id,\n            relname as name,\n            relnamespace as schema,\n            relkind as kind\n        from pg_class\n    ),\n    dependency as (\n        select\n            pg_depend.objid as id,\n            pg_depend.refobjid as ref\n        from pg_depend\n    ),\n    schema as (\n        select\n            pg_namespace.oid as id,\n            pg_namespace.nspname as name\n        from pg_namespace\n        where nspname != 'information_schema' and nspname not like 'pg_%'\n    ),\n    referenced as (\n        select\n            relation.id AS id,\n            referenced_class.name ,\n            referenced_class.schema ,\n            referenced_class.kind\n        from relation\n        join class as referenced_class on relation.class=referenced_class.id\n        where referenced_class.kind in ('r', 'v')\n    ),\n    relationships as (\n        select\n            referenced.name as referenced_name,\n            referenced.schema as referenced_schema_id,\n            dependent_class.name as dependent_name,\n            dependent_class.schema as dependent_schema_id,\n            referenced.kind as kind\n        from referenced\n        join dependency on referenced.id=dependency.id\n        join class as dependent_class on dependency.ref=dependent_class.id\n        where\n            (referenced.name != dependent_class.name or\n             referenced.schema != dependent_class.schema)\n    )\n\n    select\n        referenced_schema.name as referenced_schema,\n        relationships.referenced_name as referenced_name,\n        dependent_schema.name as dependent_schema,\n        relationships.dependent_name as dependent_name\n    from relationships\n    join schema as dependent_schema on relationships.dependent_schema_id=dependent_schema.id\n    join schema as referenced_schema on relationships.referenced_schema_id=referenced_schema.id\n    group by referenced_schema, referenced_name, dependent_schema, dependent_name\n    order by referenced_schema, referenced_name, dependent_schema, dependent_name;\n\n  {%- endcall -%}\n\n  {{ return(load_result('relations').table) }}\n{% endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/postgres", "name": "postgres_get_relations", "unique_id": "macro.dbt_postgres.postgres_get_relations", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt_postgres.postgres__create_schema": {"path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "package_name": "dbt_postgres", "raw_sql": "{% macro postgres__create_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{ schema_name }}\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__drop_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{ schema_name }} cascade\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from {{ relation.information_schema('columns') }}\n      where table_name = '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema = '{{ relation.schema }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n{% endmacro %}\n\n\n{% macro postgres__list_relations_without_caching(information_schema, schema) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      tablename as name,\n      schemaname as schema,\n      'table' as type\n    from pg_tables\n    where schemaname ilike '{{ schema }}'\n    union all\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      viewname as name,\n      schemaname as schema,\n      'view' as type\n    from pg_views\n    where schemaname ilike '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}\n\n{% macro postgres__information_schema_name(database) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  information_schema\n{%- endmacro %}\n\n{% macro postgres__list_schemas(database) %}\n  {% if database -%}\n    {{ adapter.verify_database(database) }}\n  {%- endif -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct nspname from pg_namespace\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n{% macro postgres__check_schema_exists(information_schema, schema) -%}\n  {% if database -%}\n    {{ adapter.verify_database(information_schema.database) }}\n  {%- endif -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) %}\n    select count(*) from pg_namespace where nspname = '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro postgres__current_timestamp() -%}\n  now()\n{%- endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/postgres", "name": "postgres__create_schema", "unique_id": "macro.dbt_postgres.postgres__create_schema", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt_postgres.postgres__drop_schema": {"path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "package_name": "dbt_postgres", "raw_sql": "{% macro postgres__create_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{ schema_name }}\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__drop_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{ schema_name }} cascade\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from {{ relation.information_schema('columns') }}\n      where table_name = '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema = '{{ relation.schema }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n{% endmacro %}\n\n\n{% macro postgres__list_relations_without_caching(information_schema, schema) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      tablename as name,\n      schemaname as schema,\n      'table' as type\n    from pg_tables\n    where schemaname ilike '{{ schema }}'\n    union all\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      viewname as name,\n      schemaname as schema,\n      'view' as type\n    from pg_views\n    where schemaname ilike '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}\n\n{% macro postgres__information_schema_name(database) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  information_schema\n{%- endmacro %}\n\n{% macro postgres__list_schemas(database) %}\n  {% if database -%}\n    {{ adapter.verify_database(database) }}\n  {%- endif -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct nspname from pg_namespace\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n{% macro postgres__check_schema_exists(information_schema, schema) -%}\n  {% if database -%}\n    {{ adapter.verify_database(information_schema.database) }}\n  {%- endif -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) %}\n    select count(*) from pg_namespace where nspname = '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro postgres__current_timestamp() -%}\n  now()\n{%- endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/postgres", "name": "postgres__drop_schema", "unique_id": "macro.dbt_postgres.postgres__drop_schema", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt_postgres.postgres__get_columns_in_relation": {"path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "package_name": "dbt_postgres", "raw_sql": "{% macro postgres__create_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{ schema_name }}\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__drop_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{ schema_name }} cascade\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from {{ relation.information_schema('columns') }}\n      where table_name = '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema = '{{ relation.schema }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n{% endmacro %}\n\n\n{% macro postgres__list_relations_without_caching(information_schema, schema) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      tablename as name,\n      schemaname as schema,\n      'table' as type\n    from pg_tables\n    where schemaname ilike '{{ schema }}'\n    union all\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      viewname as name,\n      schemaname as schema,\n      'view' as type\n    from pg_views\n    where schemaname ilike '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}\n\n{% macro postgres__information_schema_name(database) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  information_schema\n{%- endmacro %}\n\n{% macro postgres__list_schemas(database) %}\n  {% if database -%}\n    {{ adapter.verify_database(database) }}\n  {%- endif -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct nspname from pg_namespace\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n{% macro postgres__check_schema_exists(information_schema, schema) -%}\n  {% if database -%}\n    {{ adapter.verify_database(information_schema.database) }}\n  {%- endif -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) %}\n    select count(*) from pg_namespace where nspname = '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro postgres__current_timestamp() -%}\n  now()\n{%- endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/postgres", "name": "postgres__get_columns_in_relation", "unique_id": "macro.dbt_postgres.postgres__get_columns_in_relation", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt_postgres.postgres__list_relations_without_caching": {"path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "package_name": "dbt_postgres", "raw_sql": "{% macro postgres__create_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{ schema_name }}\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__drop_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{ schema_name }} cascade\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from {{ relation.information_schema('columns') }}\n      where table_name = '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema = '{{ relation.schema }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n{% endmacro %}\n\n\n{% macro postgres__list_relations_without_caching(information_schema, schema) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      tablename as name,\n      schemaname as schema,\n      'table' as type\n    from pg_tables\n    where schemaname ilike '{{ schema }}'\n    union all\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      viewname as name,\n      schemaname as schema,\n      'view' as type\n    from pg_views\n    where schemaname ilike '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}\n\n{% macro postgres__information_schema_name(database) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  information_schema\n{%- endmacro %}\n\n{% macro postgres__list_schemas(database) %}\n  {% if database -%}\n    {{ adapter.verify_database(database) }}\n  {%- endif -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct nspname from pg_namespace\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n{% macro postgres__check_schema_exists(information_schema, schema) -%}\n  {% if database -%}\n    {{ adapter.verify_database(information_schema.database) }}\n  {%- endif -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) %}\n    select count(*) from pg_namespace where nspname = '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro postgres__current_timestamp() -%}\n  now()\n{%- endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/postgres", "name": "postgres__list_relations_without_caching", "unique_id": "macro.dbt_postgres.postgres__list_relations_without_caching", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt_postgres.postgres__information_schema_name": {"path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "package_name": "dbt_postgres", "raw_sql": "{% macro postgres__create_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{ schema_name }}\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__drop_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{ schema_name }} cascade\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from {{ relation.information_schema('columns') }}\n      where table_name = '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema = '{{ relation.schema }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n{% endmacro %}\n\n\n{% macro postgres__list_relations_without_caching(information_schema, schema) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      tablename as name,\n      schemaname as schema,\n      'table' as type\n    from pg_tables\n    where schemaname ilike '{{ schema }}'\n    union all\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      viewname as name,\n      schemaname as schema,\n      'view' as type\n    from pg_views\n    where schemaname ilike '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}\n\n{% macro postgres__information_schema_name(database) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  information_schema\n{%- endmacro %}\n\n{% macro postgres__list_schemas(database) %}\n  {% if database -%}\n    {{ adapter.verify_database(database) }}\n  {%- endif -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct nspname from pg_namespace\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n{% macro postgres__check_schema_exists(information_schema, schema) -%}\n  {% if database -%}\n    {{ adapter.verify_database(information_schema.database) }}\n  {%- endif -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) %}\n    select count(*) from pg_namespace where nspname = '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro postgres__current_timestamp() -%}\n  now()\n{%- endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/postgres", "name": "postgres__information_schema_name", "unique_id": "macro.dbt_postgres.postgres__information_schema_name", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt_postgres.postgres__list_schemas": {"path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "package_name": "dbt_postgres", "raw_sql": "{% macro postgres__create_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{ schema_name }}\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__drop_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{ schema_name }} cascade\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from {{ relation.information_schema('columns') }}\n      where table_name = '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema = '{{ relation.schema }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n{% endmacro %}\n\n\n{% macro postgres__list_relations_without_caching(information_schema, schema) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      tablename as name,\n      schemaname as schema,\n      'table' as type\n    from pg_tables\n    where schemaname ilike '{{ schema }}'\n    union all\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      viewname as name,\n      schemaname as schema,\n      'view' as type\n    from pg_views\n    where schemaname ilike '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}\n\n{% macro postgres__information_schema_name(database) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  information_schema\n{%- endmacro %}\n\n{% macro postgres__list_schemas(database) %}\n  {% if database -%}\n    {{ adapter.verify_database(database) }}\n  {%- endif -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct nspname from pg_namespace\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n{% macro postgres__check_schema_exists(information_schema, schema) -%}\n  {% if database -%}\n    {{ adapter.verify_database(information_schema.database) }}\n  {%- endif -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) %}\n    select count(*) from pg_namespace where nspname = '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro postgres__current_timestamp() -%}\n  now()\n{%- endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/postgres", "name": "postgres__list_schemas", "unique_id": "macro.dbt_postgres.postgres__list_schemas", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt_postgres.postgres__check_schema_exists": {"path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "package_name": "dbt_postgres", "raw_sql": "{% macro postgres__create_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{ schema_name }}\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__drop_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{ schema_name }} cascade\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from {{ relation.information_schema('columns') }}\n      where table_name = '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema = '{{ relation.schema }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n{% endmacro %}\n\n\n{% macro postgres__list_relations_without_caching(information_schema, schema) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      tablename as name,\n      schemaname as schema,\n      'table' as type\n    from pg_tables\n    where schemaname ilike '{{ schema }}'\n    union all\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      viewname as name,\n      schemaname as schema,\n      'view' as type\n    from pg_views\n    where schemaname ilike '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}\n\n{% macro postgres__information_schema_name(database) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  information_schema\n{%- endmacro %}\n\n{% macro postgres__list_schemas(database) %}\n  {% if database -%}\n    {{ adapter.verify_database(database) }}\n  {%- endif -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct nspname from pg_namespace\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n{% macro postgres__check_schema_exists(information_schema, schema) -%}\n  {% if database -%}\n    {{ adapter.verify_database(information_schema.database) }}\n  {%- endif -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) %}\n    select count(*) from pg_namespace where nspname = '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro postgres__current_timestamp() -%}\n  now()\n{%- endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/postgres", "name": "postgres__check_schema_exists", "unique_id": "macro.dbt_postgres.postgres__check_schema_exists", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}, "macro.dbt_postgres.postgres__current_timestamp": {"path": "macros/adapters.sql", "original_file_path": "macros/adapters.sql", "package_name": "dbt_postgres", "raw_sql": "{% macro postgres__create_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('create_schema') -%}\n    create schema if not exists {{ schema_name }}\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__drop_schema(database_name, schema_name) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  {%- call statement('drop_schema') -%}\n    drop schema if exists {{ schema_name }} cascade\n  {%- endcall -%}\n{% endmacro %}\n\n{% macro postgres__get_columns_in_relation(relation) -%}\n  {% call statement('get_columns_in_relation', fetch_result=True) %}\n      select\n          column_name,\n          data_type,\n          character_maximum_length,\n          numeric_precision,\n          numeric_scale\n\n      from {{ relation.information_schema('columns') }}\n      where table_name = '{{ relation.identifier }}'\n        {% if relation.schema %}\n        and table_schema = '{{ relation.schema }}'\n        {% endif %}\n      order by ordinal_position\n\n  {% endcall %}\n  {% set table = load_result('get_columns_in_relation').table %}\n  {{ return(sql_convert_columns_in_relation(table)) }}\n{% endmacro %}\n\n\n{% macro postgres__list_relations_without_caching(information_schema, schema) %}\n  {% call statement('list_relations_without_caching', fetch_result=True) -%}\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      tablename as name,\n      schemaname as schema,\n      'table' as type\n    from pg_tables\n    where schemaname ilike '{{ schema }}'\n    union all\n    select\n      '{{ information_schema.database.lower() }}' as database,\n      viewname as name,\n      schemaname as schema,\n      'view' as type\n    from pg_views\n    where schemaname ilike '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('list_relations_without_caching').table) }}\n{% endmacro %}\n\n{% macro postgres__information_schema_name(database) -%}\n  {% if database_name -%}\n    {{ adapter.verify_database(database_name) }}\n  {%- endif -%}\n  information_schema\n{%- endmacro %}\n\n{% macro postgres__list_schemas(database) %}\n  {% if database -%}\n    {{ adapter.verify_database(database) }}\n  {%- endif -%}\n  {% call statement('list_schemas', fetch_result=True, auto_begin=False) %}\n    select distinct nspname from pg_namespace\n  {% endcall %}\n  {{ return(load_result('list_schemas').table) }}\n{% endmacro %}\n\n{% macro postgres__check_schema_exists(information_schema, schema) -%}\n  {% if database -%}\n    {{ adapter.verify_database(information_schema.database) }}\n  {%- endif -%}\n  {% call statement('check_schema_exists', fetch_result=True, auto_begin=False) %}\n    select count(*) from pg_namespace where nspname = '{{ schema }}'\n  {% endcall %}\n  {{ return(load_result('check_schema_exists').table) }}\n{% endmacro %}\n\n\n{% macro postgres__current_timestamp() -%}\n  now()\n{%- endmacro %}", "root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/postgres", "name": "postgres__current_timestamp", "unique_id": "macro.dbt_postgres.postgres__current_timestamp", "tags": [], "resource_type": "macro", "depends_on": {"macros": []}}}, "docs": {"jaffle_shop.__overview__": {"root_path": "/Users/drew/fishtown/clients/jaffle_shop", "resource_type": "documentation", "path": "overview.md", "original_file_path": "models/overview.md", "package_name": "jaffle_shop", "file_contents": "{% docs __overview__ %}\n\n## Data Documentation for Jaffle Shop\n\n`jaffle_shop` is a fictional ecommerce store.\n\nThis [dbt](https://www.getdbt.com/) project is for demonstrations and tutorials.\n\nThe source code can be found [here](https://github.com/clrcrl/jaffle_shop).\n\n{% enddocs %}\n", "name": "__overview__", "unique_id": "jaffle_shop.__overview__", "block_contents": "## Data Documentation for Jaffle Shop\n\n`jaffle_shop` is a fictional ecommerce store.\n\nThis [dbt](https://www.getdbt.com/) project is for demonstrations and tutorials.\n\nThe source code can be found [here](https://github.com/clrcrl/jaffle_shop)."}, "jaffle_shop.orders_status": {"root_path": "/Users/drew/fishtown/clients/jaffle_shop", "resource_type": "documentation", "path": "marts/core/docs.md", "original_file_path": "models/marts/core/docs.md", "package_name": "jaffle_shop", "file_contents": "{% docs orders_status %}\n\nOrders can be one of the following statuses:\n\n| status         | description                                                                                                            |\n|----------------|------------------------------------------------------------------------------------------------------------------------|\n| placed         | The order has been placed but has not yet left the warehouse                                                           |\n| shipped        | The order has ben shipped to the customer and is currently in transit                                                  |\n| completed      | The order has been received by the customer                                                                            |\n| return_pending | The customer has indicated that they would like to return the order, but it has not yet been received at the warehouse |\n| returned       | The order has been returned by the customer and received at the warehouse                                              |\n\n\n{% enddocs %}\n", "name": "orders_status", "unique_id": "jaffle_shop.orders_status", "block_contents": "Orders can be one of the following statuses:\n\n| status         | description                                                                                                            |\n|----------------|------------------------------------------------------------------------------------------------------------------------|\n| placed         | The order has been placed but has not yet left the warehouse                                                           |\n| shipped        | The order has ben shipped to the customer and is currently in transit                                                  |\n| completed      | The order has been received by the customer                                                                            |\n| return_pending | The customer has indicated that they would like to return the order, but it has not yet been received at the warehouse |\n| returned       | The order has been returned by the customer and received at the warehouse                                              |"}, "dbt.__overview__": {"root_path": "/usr/local/Cellar/dbt/0.13.1/libexec/lib/python3.7/site-packages/dbt/include/global_project", "resource_type": "documentation", "path": "overview.md", "original_file_path": "docs/overview.md", "package_name": "dbt", "file_contents": "\n{% docs __overview__ %}\n\n### Welcome!\n\nWelcome to the auto-generated documentation for your dbt project!\n\n### Navigation\n\nYou can use the `Project` and `Database` navigation tabs on the left side of the window to explore the models\nin your project.\n\n#### Project Tab\nThe `Project` tab mirrors the directory structure of your dbt project. In this tab, you can see all of the\nmodels defined in your dbt project, as well as models imported from dbt packages.\n\n#### Database Tab\nThe `Database` tab also exposes your models, but in a format that looks more like a database explorer. This view\nshows relations (tables and views) grouped into database schemas. Note that ephemeral models are _not_ shown\nin this interface, as they do not exist in the database.\n\n### Graph Exploration\nYou can click the blue icon on the bottom-right corner of the page to view the lineage graph of your models.\n\nOn model pages, you'll see the immediate parents and children of the model you're exploring. By clicking the `Expand`\nbutton at the top-right of this lineage pane, you'll be able to see all of the models that are used to build,\nor are built from, the model you're exploring.\n\nOnce expanded, you'll be able to use the `--models` and `--exclude` model selection syntax to filter the\nmodels in the graph. For more information on model selection, check out the [dbt docs](https://docs.getdbt.com/reference#section-specifying-models-to-run).\n\nNote that you can also right-click on models to interactively filter and explore the graph.\n\n---\n\n### More information\n\n- [What is dbt](https://docs.getdbt.com/docs/overview)?\n- Read the [dbt viewpoint](https://docs.getdbt.com/docs/viewpoint)\n- [Installation](https://docs.getdbt.com/docs/installation)\n- Join the [chat](https://slack.getdbt.com/) on Slack for live questions and support.\n\n{% enddocs %}\n", "name": "__overview__", "unique_id": "dbt.__overview__", "block_contents": "### Welcome!\n\nWelcome to the auto-generated documentation for your dbt project!\n\n### Navigation\n\nYou can use the `Project` and `Database` navigation tabs on the left side of the window to explore the models\nin your project.\n\n#### Project Tab\nThe `Project` tab mirrors the directory structure of your dbt project. In this tab, you can see all of the\nmodels defined in your dbt project, as well as models imported from dbt packages.\n\n#### Database Tab\nThe `Database` tab also exposes your models, but in a format that looks more like a database explorer. This view\nshows relations (tables and views) grouped into database schemas. Note that ephemeral models are _not_ shown\nin this interface, as they do not exist in the database.\n\n### Graph Exploration\nYou can click the blue icon on the bottom-right corner of the page to view the lineage graph of your models.\n\nOn model pages, you'll see the immediate parents and children of the model you're exploring. By clicking the `Expand`\nbutton at the top-right of this lineage pane, you'll be able to see all of the models that are used to build,\nor are built from, the model you're exploring.\n\nOnce expanded, you'll be able to use the `--models` and `--exclude` model selection syntax to filter the\nmodels in the graph. For more information on model selection, check out the [dbt docs](https://docs.getdbt.com/reference#section-specifying-models-to-run).\n\nNote that you can also right-click on models to interactively filter and explore the graph.\n\n---\n\n### More information\n\n- [What is dbt](https://docs.getdbt.com/docs/overview)?\n- Read the [dbt viewpoint](https://docs.getdbt.com/docs/viewpoint)\n- [Installation](https://docs.getdbt.com/docs/installation)\n- Join the [chat](https://slack.getdbt.com/) on Slack for live questions and support."}}, "parent_map": {"model.jaffle_shop.stg_customers": ["seed.jaffle_shop.raw_customers"], "model.jaffle_shop.stg_payments": ["seed.jaffle_shop.raw_payments"], "model.jaffle_shop.stg_orders": ["seed.jaffle_shop.raw_orders"], "model.jaffle_shop.dim_customers": ["model.jaffle_shop.customer_orders", "model.jaffle_shop.customer_payments", "model.jaffle_shop.stg_customers"], "model.jaffle_shop.fct_orders": ["model.jaffle_shop.order_payments", "model.jaffle_shop.stg_orders"], "model.jaffle_shop.order_payments": ["model.jaffle_shop.stg_payments"], "model.jaffle_shop.customer_payments": ["model.jaffle_shop.stg_orders", "model.jaffle_shop.stg_payments"], "model.jaffle_shop.customer_orders": ["model.jaffle_shop.stg_orders"], "seed.jaffle_shop.raw_customers": [], "seed.jaffle_shop.raw_orders": [], "seed.jaffle_shop.raw_payments": [], "test.jaffle_shop.unique_stg_customers_customer_id": ["model.jaffle_shop.stg_customers"], "test.jaffle_shop.not_null_stg_customers_customer_id": ["model.jaffle_shop.stg_customers"], "test.jaffle_shop.unique_stg_orders_order_id": ["model.jaffle_shop.stg_orders"], "test.jaffle_shop.not_null_stg_orders_order_id": ["model.jaffle_shop.stg_orders"], "test.jaffle_shop.accepted_values_stg_orders_status__placed__shipped__completed__return_pending__returned": ["model.jaffle_shop.stg_orders"], "test.jaffle_shop.unique_stg_payments_payment_id": ["model.jaffle_shop.stg_payments"], "test.jaffle_shop.not_null_stg_payments_payment_id": ["model.jaffle_shop.stg_payments"], "test.jaffle_shop.accepted_values_stg_payments_payment_method__credit_card__coupon__bank_transfer__gift_card": ["model.jaffle_shop.stg_payments"], "test.jaffle_shop.unique_dim_customers_customer_id": ["model.jaffle_shop.dim_customers"], "test.jaffle_shop.not_null_dim_customers_customer_id": ["model.jaffle_shop.dim_customers"], "test.jaffle_shop.unique_fct_orders_order_id": ["model.jaffle_shop.fct_orders"], "test.jaffle_shop.not_null_fct_orders_order_id": ["model.jaffle_shop.fct_orders"], "test.jaffle_shop.not_null_fct_orders_customer_id": ["model.jaffle_shop.fct_orders"], "test.jaffle_shop.relationships_fct_orders_customer_id__customer_id__ref_dim_customers_": ["model.jaffle_shop.dim_customers", "model.jaffle_shop.fct_orders"], "test.jaffle_shop.accepted_values_fct_orders_status__placed__shipped__completed__return_pending__returned": ["model.jaffle_shop.fct_orders"], "test.jaffle_shop.not_null_fct_orders_amount": ["model.jaffle_shop.fct_orders"], "test.jaffle_shop.not_null_fct_orders_credit_card_amount": ["model.jaffle_shop.fct_orders"], "test.jaffle_shop.not_null_fct_orders_coupon_amount": ["model.jaffle_shop.fct_orders"], "test.jaffle_shop.not_null_fct_orders_bank_transfer_amount": ["model.jaffle_shop.fct_orders"], "test.jaffle_shop.not_null_fct_orders_gift_card_amount": ["model.jaffle_shop.fct_orders"]}, "child_map": {"model.jaffle_shop.stg_customers": ["model.jaffle_shop.dim_customers", "test.jaffle_shop.not_null_stg_customers_customer_id", "test.jaffle_shop.unique_stg_customers_customer_id"], "model.jaffle_shop.stg_payments": ["model.jaffle_shop.customer_payments", "model.jaffle_shop.order_payments", "test.jaffle_shop.accepted_values_stg_payments_payment_method__credit_card__coupon__bank_transfer__gift_card", "test.jaffle_shop.not_null_stg_payments_payment_id", "test.jaffle_shop.unique_stg_payments_payment_id"], "model.jaffle_shop.stg_orders": ["model.jaffle_shop.customer_orders", "model.jaffle_shop.customer_payments", "model.jaffle_shop.fct_orders", "test.jaffle_shop.accepted_values_stg_orders_status__placed__shipped__completed__return_pending__returned", "test.jaffle_shop.not_null_stg_orders_order_id", "test.jaffle_shop.unique_stg_orders_order_id"], "model.jaffle_shop.dim_customers": ["test.jaffle_shop.not_null_dim_customers_customer_id", "test.jaffle_shop.relationships_fct_orders_customer_id__customer_id__ref_dim_customers_", "test.jaffle_shop.unique_dim_customers_customer_id"], "model.jaffle_shop.fct_orders": ["test.jaffle_shop.accepted_values_fct_orders_status__placed__shipped__completed__return_pending__returned", "test.jaffle_shop.not_null_fct_orders_amount", "test.jaffle_shop.not_null_fct_orders_bank_transfer_amount", "test.jaffle_shop.not_null_fct_orders_coupon_amount", "test.jaffle_shop.not_null_fct_orders_credit_card_amount", "test.jaffle_shop.not_null_fct_orders_customer_id", "test.jaffle_shop.not_null_fct_orders_gift_card_amount", "test.jaffle_shop.not_null_fct_orders_order_id", "test.jaffle_shop.relationships_fct_orders_customer_id__customer_id__ref_dim_customers_", "test.jaffle_shop.unique_fct_orders_order_id"], "model.jaffle_shop.order_payments": ["model.jaffle_shop.fct_orders"], "model.jaffle_shop.customer_payments": ["model.jaffle_shop.dim_customers"], "model.jaffle_shop.customer_orders": ["model.jaffle_shop.dim_customers"], "seed.jaffle_shop.raw_customers": ["model.jaffle_shop.stg_customers"], "seed.jaffle_shop.raw_orders": ["model.jaffle_shop.stg_orders"], "seed.jaffle_shop.raw_payments": ["model.jaffle_shop.stg_payments"], "test.jaffle_shop.unique_stg_customers_customer_id": [], "test.jaffle_shop.not_null_stg_customers_customer_id": [], "test.jaffle_shop.unique_stg_orders_order_id": [], "test.jaffle_shop.not_null_stg_orders_order_id": [], "test.jaffle_shop.accepted_values_stg_orders_status__placed__shipped__completed__return_pending__returned": [], "test.jaffle_shop.unique_stg_payments_payment_id": [], "test.jaffle_shop.not_null_stg_payments_payment_id": [], "test.jaffle_shop.accepted_values_stg_payments_payment_method__credit_card__coupon__bank_transfer__gift_card": [], "test.jaffle_shop.unique_dim_customers_customer_id": [], "test.jaffle_shop.not_null_dim_customers_customer_id": [], "test.jaffle_shop.unique_fct_orders_order_id": [], "test.jaffle_shop.not_null_fct_orders_order_id": [], "test.jaffle_shop.not_null_fct_orders_customer_id": [], "test.jaffle_shop.relationships_fct_orders_customer_id__customer_id__ref_dim_customers_": [], "test.jaffle_shop.accepted_values_fct_orders_status__placed__shipped__completed__return_pending__returned": [], "test.jaffle_shop.not_null_fct_orders_amount": [], "test.jaffle_shop.not_null_fct_orders_credit_card_amount": [], "test.jaffle_shop.not_null_fct_orders_coupon_amount": [], "test.jaffle_shop.not_null_fct_orders_bank_transfer_amount": [], "test.jaffle_shop.not_null_fct_orders_gift_card_amount": []}, "generated_at": "2019-05-20T15:23:21.771809Z", "metadata": {"project_id": "06e5b98c2db46f8a72cc4f66410e9b3b", "user_id": null, "send_anonymous_usage_stats": false}, "disabled": []}